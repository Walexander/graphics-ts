var Er=Object.defineProperty;var br=(t,e,n)=>e in t?Er(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var l=(t,e,n)=>(br(t,typeof e!="symbol"?e+"":e,n),n);import{aD as Cr,aE as yr,aF as wr,aG as Pr,aH as Or,aI as Ir,aJ as vr,aK as kr,aL as Fr,aM as Dr,aN as Rr,aO as $r,aP as qn,aQ as Wn,aR as Bn,aS as ae,aT as h,av as je,aU as pt,aV as jn,aW as Tr,aX as Ar,aY as Lr,aZ as xr,a_ as zr,a$ as Nr,b0 as Ur,b1 as Mr,b2 as qr,D as o,b3 as ve,b4 as ie,b5 as ct,b6 as Wr,b7 as Br,b8 as Qn,b9 as X,ba as se,bb as jr,bc as re,bd as K,be as M,bf as j,bg as Qr,bh as Lt,bi as Hr,bj as Hn,bk as Kr,bl as Vr,bm as Gr,bn as Kn,bo as Vn,bp as xt,bq as bn,br as Jr,bs as Yr,bt as Gn,bu as Jn,bv as Yn,bw as zt,bx as Pt,_ as Cn,by as Zr,bz as Zn,bA as Xr,bB as ei,bC as U,bD as Xn,bE as Q,bF as mt,bG as Qe,Z as b,bH as ti,bI as _t,bJ as z,au as I,p as yn,bK as J,m as P,l as p,bL as y,bM as nt,bN as es,bO as Xe,bP as et,H as O,z as Nt,S as ke,a4 as x,bQ as st,V as ni,bR as Zt,bS as si,bT as pe,bU as ri,bV as w,bW as wn,a as ii,bX as oi,bY as W,bZ as ci,b_ as Xt,b$ as Ut,c0 as ai,c1 as ts,c2 as en,c3 as Z,c4 as ee,al as ns,c5 as he,c6 as Te,c7 as ui,c8 as Se,c9 as Fe,ca as Ue,cb as ss,cc as rs,cd as at,ce as li,cf as Me,cg as ut,ch as is,ci as hi,cj as di,a3 as os,ak as Ne,ck as cs,cl as Mt,cm as fi,cn as pi,co as mi,ae as we,an as _i,cp as _e,cq as Ot,cr as Pn,cs as gi,ct as Si,cu as Ei,cv as bi,cw as as,cx as Ci,cy as yi,cz as wi,Y as ue,a0 as us,cA as ls,cB as hs,cC as ds,cD as Pi,cE as Oi,cF as Ii,cG as vi,cH as De,cI as On,cJ as ki,cK as Fi,cL as Di,cM as Ri,cN as $i,cO as Ti,a1 as Ai,cP as It,cQ as vt}from"./Shape-4cee9570.js";const Li=wr,qt=Cr,xi=Pr,zi=Or,fs=Dr,B=Ir,Ni=Rr,Y=yr,q=vr,Ui=kr,In=$r,qe=Fr,vn=Symbol.for("effect/MutableList"),Mi={[vn]:vn,[Symbol.iterator](){let t=!1,e=this.head;return{next(){if(t)return this.return();if(e==null)return t=!0,this.return();const n=e.value;return e=e.next,{done:t,value:n}},return(n){return t||(t=!0),{done:!0,value:n}}}},toString(){return qn(this.toJSON())},toJSON(){return{_id:"MutableList",values:Array.from(this).map(Wn)}},[Bn](){return this.toJSON()},pipe(){return ae(this,arguments)}};class qi{constructor(e){l(this,"value");l(this,"removed",!1);l(this,"prev");l(this,"next");this.value=e}}const Wi=()=>{const t=Object.create(Mi);return t.head=void 0,t.tail=void 0,t._length=0,t},ps=t=>tn(t)===0,tn=t=>t._length,Bi=h(2,(t,e)=>{const n=new qi(e);return t.head===void 0&&(t.head=n),t.tail===void 0||(t.tail.next=n,n.prev=t.tail),t.tail=n,t._length+=1,t}),ji=t=>{const e=t.head;if(e!==void 0)return Qi(t,e),e.value},Qi=(t,e)=>{e.removed||(e.removed=!0,e.prev!==void 0&&e.next!==void 0?(e.prev.next=e.next,e.next.prev=e.prev):e.prev!==void 0?(t.tail=e.prev,e.prev.next=void 0):e.next!==void 0?(t.head=e.next,e.next.prev=void 0):(t.tail=void 0,t.head=void 0),t._length>0&&(t._length-=1))},kn=Symbol.for("effect/MutableQueue"),L=Symbol.for("effect/mutable/MutableQueue/Empty"),Hi={[kn]:kn,[Symbol.iterator](){return Array.from(this.queue)[Symbol.iterator]()},toString(){return qn(this.toJSON())},toJSON(){return{_id:"MutableQueue",values:Array.from(this).map(Wn)}},[Bn](){return this.toJSON()},pipe(){return ae(this,arguments)}},ms=t=>{const e=Object.create(Hi);return e.queue=Wi(),e.capacity=t,e},Ki=t=>ms(t),nn=()=>ms(void 0),sn=t=>tn(t.queue),Wt=t=>ps(t.queue),Vi=t=>t.capacity===void 0?1/0:t.capacity,We=h(2,(t,e)=>{const n=tn(t.queue);return t.capacity!==void 0&&n===t.capacity?!1:(Bi(e)(t.queue),!0)}),_s=h(2,(t,e)=>{const n=e[Symbol.iterator]();let s,r=je(),i=!0;for(;i&&(s=n.next())&&!s.done;)i=We(s.value)(t);for(;s!=null&&!s.done;)r=pt(s.value)(r),s=n.next();return jn(r)}),oe=h(2,(t,e)=>ps(t.queue)?e:ji(t.queue)),rn=h(2,(t,e)=>{let n=je(),s=0;for(;s<e;){const r=oe(L)(t);if(r===L)break;n=pt(r)(n),s+=1}return jn(n)}),Gi=zr,Fn=Tr,Ji=Ar,Yi=Lr,Zi=xr,Xi=qr,eo=Nr,Pe=Ur,Dn=Mr,to="effect/QueueEnqueue",no=Symbol.for(to),so="effect/QueueDequeue",ro=Symbol.for(so),io="effect/QueueStrategy",gs=Symbol.for(io),Ss={_A:t=>t},oo={_In:t=>t},co={_Out:t=>t};var Ua,Ma;class ao{constructor(e,n,s,r,i){l(this,"queue");l(this,"takers");l(this,"shutdownHook");l(this,"shutdownFlag");l(this,"strategy");l(this,Ua,oo);l(this,Ma,co);this.queue=e,this.takers=n,this.shutdownHook=s,this.shutdownFlag=r,this.strategy=i}pipe(){return ae(this,arguments)}capacity(){return this.queue.capacity()}get size(){return se(()=>jr(this.unsafeSize(),()=>re))}unsafeSize(){return K(this.shutdownFlag)?M():j(this.queue.length()-sn(this.takers)+this.strategy.surplusSize())}get isEmpty(){return ct(this.size,e=>e<=0)}get isFull(){return ct(this.size,e=>e>=this.capacity())}get shutdown(){return Qr(Lt(e=>(o(this.shutdownFlag,Hr(!0)),o(Kn(Oe(this.takers),n=>Vn(n,e.id()),!1),Gr(this.strategy.shutdown),Kr(Vr(this.shutdownHook,void 0)),Hn))))}get isShutdown(){return ie(()=>K(this.shutdownFlag))}get awaitShutdown(){return xt(this.shutdownHook)}isActive(){return!K(this.shutdownFlag)}unsafeOffer(e){if(K(this.shutdownFlag))return!1;let n;if(this.queue.length()===0){const r=o(this.takers,oe(L));r!==L?(me(r,e),n=!0):n=!1}else n=!1;if(n)return!0;const s=this.queue.offer(e);return Ce(this.strategy,this.queue,this.takers),s}offer(e){return se(()=>{if(K(this.shutdownFlag))return re;let n;if(this.queue.length()===0){const r=o(this.takers,oe(L));r!==L?(me(r,e),n=!0):n=!1}else n=!1;if(n)return X(!0);const s=this.queue.offer(e);return Ce(this.strategy,this.queue,this.takers),s?X(!0):this.strategy.handleSurplus([e],this.queue,this.takers,this.shutdownFlag)})}offerAll(e){return se(()=>{if(K(this.shutdownFlag))return re;const n=bn(e),s=this.queue.length()===0?bn(Po(this.takers,n.length)):Jr,[r,i]=o(n,Yr(s.length));for(let a=0;a<s.length;a++){const u=s[a],d=r[a];me(u,d)}if(i.length===0)return X(!0);const c=this.queue.offerAll(i);return Ce(this.strategy,this.queue,this.takers),Gn(c)?X(!0):this.strategy.handleSurplus(c,this.queue,this.takers,this.shutdownFlag)})}get take(){return Lt(e=>{if(K(this.shutdownFlag))return re;const n=this.queue.poll(L);if(n!==L)return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),X(n);{const s=Jn(e.id());return o(se(()=>(o(this.takers,We(s)),Ce(this.strategy,this.queue,this.takers),K(this.shutdownFlag)?re:xt(s))),Yn(()=>ie(()=>Oo(this.takers,s))))}})}get takeAll(){return se(()=>K(this.shutdownFlag)?re:ie(()=>{const e=this.queue.pollUpTo(Number.POSITIVE_INFINITY);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),zt(e)}))}takeUpTo(e){return se(()=>K(this.shutdownFlag)?re:ie(()=>{const n=this.queue.pollUpTo(e);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),zt(n)}))}takeBetween(e,n){return se(()=>Es(this,e,n,je()))}}Ua=no,Ma=ro;const Es=(t,e,n,s)=>n<e?X(s):o(So(t,n),ve(r=>{const i=e-r.length;return i===1?o(Bt(t),ct(c=>o(s,Pt(r),Cn(c)))):i>1?o(Bt(t),ve(c=>Es(t,i-1,n-r.length-1,o(s,Pt(r),Cn(c))))):X(o(s,Pt(r)))})),uo=t=>o(ie(()=>Ki(t)),ve(e=>bs(Cs(e),bo()))),lo=()=>o(ie(()=>nn()),ve(t=>bs(Cs(t),Co()))),ho=(t,e,n,s,r)=>new ao(t,e,n,s,r),bs=(t,e)=>o(Br(),ct(n=>ho(t,nn(),n,Wr(!1),e)));class fo{constructor(e){l(this,"mutable");this.mutable=e}poll(e){return oe(this.mutable,e)}pollUpTo(e){return rn(this.mutable,e)}offerAll(e){return _s(this.mutable,e)}offer(e){return We(this.mutable,e)}capacity(){return Vi(this.mutable)}length(){return sn(this.mutable)}}const Cs=t=>new fo(t),po=t=>t.size,mo=t=>t.isShutdown,_o=t=>t.shutdown,go=h(2,(t,e)=>t.offer(e)),Bt=t=>t.take,So=h(2,(t,e)=>t.takeUpTo(e)),Eo=h(3,(t,e,n)=>t.takeBetween(e,n)),bo=()=>new yo,Co=()=>new wo;var qa;class yo{constructor(){l(this,qa,Ss);l(this,"putters",nn())}surplusSize(){return sn(this.putters)}onCompleteTakersWithEmptyQueue(e){for(;!Wt(this.putters)&&!Wt(e);){const n=oe(e,void 0),s=oe(this.putters,void 0);s[2]&&me(s[1],!0),me(n,s[0])}}get shutdown(){return o(Zr,ve(e=>o(ie(()=>Oe(this.putters)),ve(n=>Kn(n,([s,r,i])=>i?o(Vn(r,e),Hn):Qn,!1)))))}handleSurplus(e,n,s,r){return Lt(i=>{const c=Jn(i.id());return o(se(()=>(this.unsafeOffer(e,c),this.unsafeOnQueueEmptySpace(n,s),Ce(this,n,s),K(r)?re:xt(c))),Yn(()=>ie(()=>this.unsafeRemove(c))))})}unsafeOnQueueEmptySpace(e,n){let s=!0;for(;s&&(e.capacity()===Number.POSITIVE_INFINITY||e.length()<e.capacity());){const r=o(this.putters,oe(L));if(r===L)s=!1;else{const i=e.offer(r[0]);i&&r[2]?me(r[1],!0):i||lt(this.putters,o(Oe(this.putters),pt(r))),Ce(this,e,n)}}}unsafeOffer(e,n){const s=Array.from(e);for(let r=0;r<s.length;r++){const i=s[r];r===s.length-1?o(this.putters,We([i,n,!0])):o(this.putters,We([i,n,!1]))}}unsafeRemove(e){lt(this.putters,o(Oe(this.putters),Zn(([,n])=>n!==e)))}}qa=gs;var Wa;class wo{constructor(){l(this,Wa,Ss)}surplusSize(){return 0}get shutdown(){return Qn}onCompleteTakersWithEmptyQueue(){}handleSurplus(e,n,s,r){return X(!1)}unsafeOnQueueEmptySpace(e,n){}}Wa=gs;const me=(t,e)=>Xr(t,X(e)),lt=(t,e)=>o(t,_s(e)),Oe=t=>o(t,rn(Number.POSITIVE_INFINITY)),Po=(t,e)=>o(t,rn(e)),Oo=(t,e)=>{lt(t,o(Oe(t),Zn(n=>e!==n)))},Ce=(t,e,n)=>{let s=!0;for(;s&&e.length()!==0;){const r=o(n,oe(L));if(r!==L){const i=e.poll(L);i!==L?(me(r,i),t.unsafeOnQueueEmptySpace(e,n)):lt(n,o(Oe(n),pt(r))),s=!0}else s=!1}s&&e.length()===0&&!Wt(n)&&t.onCompleteTakersWithEmptyQueue(n)},on=uo,ys=lo,Io=po,vo=mo,Be=_o,$=go,jt=Bt,ko=Eo,ws="Continue",Fo="Close",Do="Yield",Ro="effect/ChannelChildExecutorDecision",Rn=Symbol.for(Ro),$o={[Rn]:Rn},Ps=t=>{const e=Object.create($o);return e._tag=ws,e},rt="ContinuationK",To="ContinuationFinalizer",Os=Symbol.for("effect/ChannelContinuation"),Is={_Env:t=>t,_InErr:t=>t,_InElem:t=>t,_InDone:t=>t,_OutErr:t=>t,_OutDone:t=>t,_OutErr2:t=>t,_OutElem:t=>t,_OutDone2:t=>t};var Ba;class cn{constructor(e,n){l(this,"onSuccess");l(this,"onHalt");l(this,"_tag",rt);l(this,Ba,Is);this.onSuccess=e,this.onHalt=n}onExit(e){return Li(e)?this.onHalt(e.cause):this.onSuccess(e.value)}}Ba=Os;var ja;class Ao{constructor(e){l(this,"finalizer");l(this,"_tag",To);l(this,ja,Is);this.finalizer=e}}ja=Os;const vs="PullAfterNext",Lo="PullAfterAllEnqueued",xo="effect/ChannelUpstreamPullStrategy",zo=Symbol.for(xo),No={_A:t=>t},Uo={[zo]:No},ks=t=>{const e=Object.create(Uo);return e._tag=vs,e.emitSeparator=t,e},Fs="BracketOut",Ds="Bridge",an="ConcatAll",Rs="Emit",$s="Ensuring",Ts="Fail",un="Fold",As="FromEffect",Ls="PipeTo",Mo="Provide",xs="Read",zs="Succeed",Ns="SucceedNow",Us="Suspend",qo="effect/Channel",Ms=Symbol.for(qo),Wo={_Env:t=>t,_InErr:t=>t,_InElem:t=>t,_InDone:t=>t,_OutErr:t=>t,_OutElem:t=>t,_OutDone:t=>t},A={[Ms]:Wo,pipe(){return ae(this,arguments)}},qs=t=>mt(t,Ms)||Qe(t),Bo=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Fs,n.acquire=()=>t,n.finalizer=e,n}),jo=h(2,(t,e)=>{const n=Object.create(A);return n._tag=un,n.channel=t,n.k=new cn(He,e),n}),Qo=(t,e,n)=>{const s=Object.create(A);return s._tag=an,s.combineInners=e,s.combineAll=n,s.onPull=()=>ks(M()),s.onEmit=()=>Ps,s.value=()=>t,s.k=Q,s},Ho=h(4,(t,e,n,s)=>{const r=Object.create(A);return r._tag=an,r.combineInners=n,r.combineAll=s,r.onPull=()=>ks(M()),r.onEmit=()=>Ps,r.value=()=>t,r.k=e,r}),Ws=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Ds,n.input=e,n.channel=t,n}),Ko=h(2,(t,e)=>{const n=Object.create(A);return n._tag=$s,n.channel=t,n.finalizer=e,n}),te=t=>F(ei(t)),F=t=>Vo(()=>t),Vo=t=>{const e=Object.create(A);return e._tag=Ts,e.error=t,e},m=h(2,(t,e)=>{const n=Object.create(A);return n._tag=un,n.channel=t,n.k=new cn(e,F),n}),R=t=>{const e=Object.create(A);return e._tag=As,e.effect=()=>t,e},T=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Ls,n.left=()=>t,n.right=()=>e,n}),Re=t=>le({onInput:t.onInput,onFailure:e=>U(Xn(e),{onLeft:t.onFailure,onRight:F}),onDone:t.onDone}),le=t=>{const e=Object.create(A);return e._tag=xs,e.more=t.onInput,e.done=new cn(t.onDone,t.onFailure),e},He=t=>Bs(()=>t),ce=t=>{const e=Object.create(A);return e._tag=Ns,e.terminal=t,e},Ke=t=>{const e=Object.create(A);return e._tag=Us,e.channel=t,e},Bs=t=>{const e=Object.create(A);return e._tag=zs,e.evaluate=t,e},N=ce(void 0),_=t=>{const e=Object.create(A);return e._tag=Rs,e.out=t,e},Ve="Done",Ge="Emit",$e="FromEffect",Je="Read",Go=Symbol.for("effect/ChannelState"),Jo={_R:t=>t,_E:t=>t},gt={[Go]:Jo},Ee=()=>{const t=Object.create(gt);return t._tag=Ve,t},kt=()=>{const t=Object.create(gt);return t._tag=Ge,t},Ae=t=>{const e=Object.create(gt);return e._tag=$e,e.effect=t,e},Ft=(t,e,n,s)=>{const r=Object.create(gt);return r._tag=Je,r.upstream=t,r.onEffect=e,r.onEmit=n,r.onDone=s,r},ht=t=>t._tag===$e,Yo=t=>ht(t)?t.effect:b,$n=t=>ht(t)?ti(t.effect):void 0,js="PullFromChild",Qt="PullFromUpstream",Ht="DrainChildExecutors",Qs="Emit";class tt{constructor(e,n,s){l(this,"childExecutor");l(this,"parentSubexecutor");l(this,"onEmit");l(this,"_tag",js);this.childExecutor=e,this.parentSubexecutor=n,this.onEmit=s}close(e){const n=this.childExecutor.close(e),s=this.parentSubexecutor.close(e);return n!==void 0&&s!==void 0?_t(z(n),z(s),(r,i)=>o(r,qe(i))):n!==void 0?n:s!==void 0?s:void 0}enqueuePullFromChild(e){return this}}class de{constructor(e,n,s,r,i,c,a,u){l(this,"upstreamExecutor");l(this,"createChild");l(this,"lastDone");l(this,"activeChildExecutors");l(this,"combineChildResults");l(this,"combineWithChildResult");l(this,"onPull");l(this,"onEmit");l(this,"_tag",Qt);this.upstreamExecutor=e,this.createChild=n,this.lastDone=s,this.activeChildExecutors=r,this.combineChildResults=i,this.combineWithChildResult=c,this.onPull=a,this.onEmit=u}close(e){const n=this.upstreamExecutor.close(e),r=[...this.activeChildExecutors.map(i=>i!==void 0?i.childExecutor.close(e):void 0),n].reduce((i,c)=>i!==void 0&&c!==void 0?_t(i,z(c),(a,u)=>qe(a,u)):i!==void 0?i:c!==void 0?z(c):void 0,void 0);return r}enqueuePullFromChild(e){return new de(this.upstreamExecutor,this.createChild,this.lastDone,[...this.activeChildExecutors,e],this.combineChildResults,this.combineWithChildResult,this.onPull,this.onEmit)}}class ye{constructor(e,n,s,r,i,c,a){l(this,"upstreamExecutor");l(this,"lastDone");l(this,"activeChildExecutors");l(this,"upstreamDone");l(this,"combineChildResults");l(this,"combineWithChildResult");l(this,"onPull");l(this,"_tag",Ht);this.upstreamExecutor=e,this.lastDone=n,this.activeChildExecutors=s,this.upstreamDone=r,this.combineChildResults=i,this.combineWithChildResult=c,this.onPull=a}close(e){const n=this.upstreamExecutor.close(e),r=[...this.activeChildExecutors.map(i=>i!==void 0?i.childExecutor.close(e):void 0),n].reduce((i,c)=>i!==void 0&&c!==void 0?_t(i,z(c),(a,u)=>qe(a,u)):i!==void 0?i:c!==void 0?z(c):void 0,void 0);return r}enqueuePullFromChild(e){return new ye(this.upstreamExecutor,this.lastDone,[...this.activeChildExecutors,e],this.upstreamDone,this.combineChildResults,this.combineWithChildResult,this.onPull)}}class Dt{constructor(e,n){l(this,"value");l(this,"next");l(this,"_tag",Qs);this.value=e,this.next=n}close(e){const n=this.next.close(e);return n}enqueuePullFromChild(e){return this}}const Zo="Pulled",Xo="NoUpstream",ec="effect/ChannelUpstreamPullRequest",tc=Symbol.for(ec),nc={_A:t=>t},Hs={[tc]:nc},Tn=t=>{const e=Object.create(Hs);return e._tag=Zo,e.value=t,e},sc=t=>{const e=Object.create(Hs);return e._tag=Xo,e.activeDownstreamCount=t,e};class fe{constructor(e,n,s){l(this,"_activeSubexecutor");l(this,"_cancelled");l(this,"_closeLastSubstream");l(this,"_currentChannel");l(this,"_done");l(this,"_doneStack",[]);l(this,"_emitted");l(this,"_executeCloseLastSubstream");l(this,"_input");l(this,"_inProgressFinalizer");l(this,"_providedEnv");this._currentChannel=e,this._executeCloseLastSubstream=s,this._providedEnv=n}run(){let e;for(;e===void 0;)if(this._cancelled!==void 0)e=this.processCancellation();else if(this._activeSubexecutor!==void 0)e=this.runSubexecutor();else try{if(this._currentChannel===void 0)e=Ee();else if(Qe(this._currentChannel))this._currentChannel=R(this._currentChannel);else switch(this._currentChannel._tag){case Fs:{e=this.runBracketOut(this._currentChannel);break}case Ds:{const n=this._currentChannel.input;if(this._currentChannel=this._currentChannel.channel,this._input!==void 0){const s=this._input;this._input=void 0;const r=()=>p(n.awaitRead(),()=>y(()=>{const i=s.run();switch(i._tag){case Ve:return Y(s.getDone(),{onFailure:c=>n.error(c),onSuccess:c=>n.done(c)});case Ge:return p(n.emit(s.getEmit()),()=>r());case $e:return J(i.effect,{onFailure:c=>n.error(c),onSuccess:()=>r()});case Je:return ln(i,()=>r(),c=>n.error(c))}}));e=Ae(p(nt(r()),i=>I(()=>this.addFinalizer(c=>p(Pe(i),()=>y(()=>{const a=this.restorePipe(c,s);return a!==void 0?a:b}))))))}break}case an:{const n=new fe(this._currentChannel.value(),this._providedEnv,r=>I(()=>{const i=this._closeLastSubstream===void 0?b:this._closeLastSubstream;this._closeLastSubstream=o(i,P(r))}));n._input=this._input;const s=this._currentChannel;this._activeSubexecutor=new de(n,r=>s.k(r),void 0,[],(r,i)=>s.combineInners(r,i),(r,i)=>s.combineAll(r,i),r=>s.onPull(r),r=>s.onEmit(r)),this._closeLastSubstream=void 0,this._currentChannel=void 0;break}case Rs:{this._emitted=this._currentChannel.out,this._currentChannel=this._activeSubexecutor!==void 0?void 0:N,e=kt();break}case $s:{this.runEnsuring(this._currentChannel);break}case Ts:{e=this.doneHalt(this._currentChannel.error());break}case un:{this._doneStack.push(this._currentChannel.k),this._currentChannel=this._currentChannel.channel;break}case As:{const n=this._providedEnv===void 0?this._currentChannel.effect():o(this._currentChannel.effect(),yn(this._providedEnv));e=Ae(J(n,{onFailure:s=>{const r=this.doneHalt(s);return r!==void 0&&ht(r)?r.effect:b},onSuccess:s=>{const r=this.doneSucceed(s);return r!==void 0&&ht(r)?r.effect:b}}));break}case Ls:{const n=this._input,s=new fe(this._currentChannel.left(),this._providedEnv,r=>this._executeCloseLastSubstream(r));s._input=n,this._input=s,this.addFinalizer(r=>{const i=this.restorePipe(r,n);return i!==void 0?i:b}),this._currentChannel=this._currentChannel.right();break}case Mo:{const n=this._providedEnv;this._providedEnv=this._currentChannel.context(),this._currentChannel=this._currentChannel.inner,this.addFinalizer(()=>I(()=>{this._providedEnv=n}));break}case xs:{const n=this._currentChannel;e=Ft(this._input,Q,s=>{try{this._currentChannel=n.more(s)}catch(r){this._currentChannel=n.done.onExit(zi(r))}},s=>{const r=i=>n.done.onExit(i);this._currentChannel=r(s)});break}case zs:{e=this.doneSucceed(this._currentChannel.evaluate());break}case Ns:{e=this.doneSucceed(this._currentChannel.terminal);break}case Us:{this._currentChannel=this._currentChannel.channel();break}default:this._currentChannel._tag}}catch(n){this._currentChannel=F(es(n))}return e}getDone(){return this._done}getEmit(){return this._emitted}cancelWith(e){this._cancelled=e}clearInProgressFinalizer(){this._inProgressFinalizer=void 0}storeInProgressFinalizer(e){this._inProgressFinalizer=e}popAllFinalizers(e){const n=[];let s=this._doneStack.pop();for(;s;)s._tag==="ContinuationFinalizer"&&n.push(s.finalizer),s=this._doneStack.pop();const r=n.length===0?b:$t(n,e);return this.storeInProgressFinalizer(r),r}popNextFinalizers(){const e=[];for(;this._doneStack.length!==0;){const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt)return e;e.push(n),this._doneStack.pop()}return e}restorePipe(e,n){const s=this._input;return this._input=n,s!==void 0?s.close(e):b}close(e){let n;const s=this._inProgressFinalizer;s!==void 0&&(n=o(s,Xe(I(()=>this.clearInProgressFinalizer()))));let r;const i=this.popAllFinalizers(e);i!==void 0&&(r=o(i,Xe(I(()=>this.clearInProgressFinalizer()))));const c=this._activeSubexecutor===void 0?void 0:this._activeSubexecutor.close(e);if(!(c===void 0&&n===void 0&&r===void 0))return o(z(Rt(c)),Nt(z(Rt(n))),Nt(z(Rt(r))),O(([[a,u],d])=>o(a,qe(u),qe(d))),et,p(a=>y(()=>a)))}doneSucceed(e){if(this._doneStack.length===0)return this._done=q(e),this._currentChannel=void 0,Ee();const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt){this._doneStack.pop(),this._currentChannel=n.onSuccess(e);return}const s=this.popNextFinalizers();if(this._doneStack.length===0)return this._doneStack=s.reverse(),this._done=q(e),this._currentChannel=void 0,Ee();const r=$t(s.map(c=>c.finalizer),q(e));this.storeInProgressFinalizer(r);const i=o(r,Xe(I(()=>this.clearInProgressFinalizer())),et,p(()=>I(()=>this.doneSucceed(e))));return Ae(i)}doneHalt(e){if(this._doneStack.length===0)return this._done=B(e),this._currentChannel=void 0,Ee();const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt){this._doneStack.pop(),this._currentChannel=n.onHalt(e);return}const s=this.popNextFinalizers();if(this._doneStack.length===0)return this._doneStack=s.reverse(),this._done=B(e),this._currentChannel=void 0,Ee();const r=$t(s.map(c=>c.finalizer),B(e));this.storeInProgressFinalizer(r);const i=o(r,Xe(I(()=>this.clearInProgressFinalizer())),et,p(()=>I(()=>this.doneHalt(e))));return Ae(i)}processCancellation(){return this._currentChannel=void 0,this._done=this._cancelled,this._cancelled=void 0,Ee()}runBracketOut(e){const n=et(J(this.provide(e.acquire()),{onFailure:s=>I(()=>{this._currentChannel=F(s)}),onSuccess:s=>I(()=>{this.addFinalizer(r=>this.provide(e.finalizer(s,r))),this._currentChannel=_(s)})}));return Ae(n)}provide(e){return this._providedEnv===void 0?e:o(e,yn(this._providedEnv))}runEnsuring(e){this.addFinalizer(e.finalizer),this._currentChannel=e.channel}addFinalizer(e){this._doneStack.push(new Ao(e))}runSubexecutor(){const e=this._activeSubexecutor;switch(e._tag){case js:return this.pullFromChild(e.childExecutor,e.parentSubexecutor,e.onEmit,e);case Qt:return this.pullFromUpstream(e);case Ht:return this.drainChildExecutors(e);case Qs:return this._emitted=e.value,this._activeSubexecutor=e.next,kt()}}replaceSubexecutor(e){this._currentChannel=void 0,this._activeSubexecutor=e}finishWithExit(e){const n=Y(e,{onFailure:s=>this.doneHalt(s),onSuccess:s=>this.doneSucceed(s)});return this._activeSubexecutor=void 0,n===void 0?b:Yo(n)}finishSubexecutorWithCloseEffect(e,...n){this.addFinalizer(()=>o(n,ke(r=>o(I(()=>r(e)),p(i=>i!==void 0?i:b)),{discard:!0})));const s=o(e,Y({onFailure:r=>this.doneHalt(r),onSuccess:r=>this.doneSucceed(r)}));return this._activeSubexecutor=void 0,s}applyUpstreamPullStrategy(e,n,s){switch(s._tag){case vs:{const r=!e||n.some(i=>i!==void 0);return[s.emitSeparator,r?[void 0,...n]:n]}case Lo:{const r=!e||n.some(i=>i!==void 0);return[s.emitSeparator,r?[...n,void 0]:n]}}}pullFromChild(e,n,s,r){return Ft(e,Q,i=>{const c=s(i);switch(c._tag){case ws:break;case Fo:{this.finishWithDoneValue(e,n,c.value);break}case Do:{const a=n.enqueuePullFromChild(r);this.replaceSubexecutor(a);break}}this._activeSubexecutor=new Dt(i,this._activeSubexecutor)},Y({onFailure:i=>{const c=this.handleSubexecutorFailure(e,n,i);return c===void 0?void 0:$n(c)},onSuccess:i=>{this.finishWithDoneValue(e,n,i)}}))}finishWithDoneValue(e,n,s){const r=n;switch(r._tag){case Qt:{const i=new de(r.upstreamExecutor,r.createChild,r.lastDone!==void 0?r.combineChildResults(r.lastDone,s):s,r.activeChildExecutors,r.combineChildResults,r.combineWithChildResult,r.onPull,r.onEmit);this._closeLastSubstream=e.close(q(s)),this.replaceSubexecutor(i);break}case Ht:{const i=new ye(r.upstreamExecutor,r.lastDone!==void 0?r.combineChildResults(r.lastDone,s):s,r.activeChildExecutors,r.upstreamDone,r.combineChildResults,r.combineWithChildResult,r.onPull);this._closeLastSubstream=e.close(q(s)),this.replaceSubexecutor(i);break}}}handleSubexecutorFailure(e,n,s){return this.finishSubexecutorWithCloseEffect(B(s),r=>n.close(r),r=>e.close(r))}pullFromUpstream(e){if(e.activeChildExecutors.length===0)return this.performPullFromUpstream(e);const n=e.activeChildExecutors[0],s=new de(e.upstreamExecutor,e.createChild,e.lastDone,e.activeChildExecutors.slice(1),e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit);if(n===void 0)return this.performPullFromUpstream(s);this.replaceSubexecutor(new tt(n.childExecutor,s,n.onEmit))}performPullFromUpstream(e){return Ft(e.upstreamExecutor,n=>{const s=this._closeLastSubstream===void 0?b:this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(s),P(n))},n=>{if(this._closeLastSubstream!==void 0){const c=this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(c),O(()=>{const a=new fe(e.createChild(n),this._providedEnv,this._executeCloseLastSubstream);a._input=this._input;const[u,d]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Tn(n)));this._activeSubexecutor=new tt(a,new de(e.upstreamExecutor,e.createChild,e.lastDone,d,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),st(u)&&(this._activeSubexecutor=new Dt(u.value,this._activeSubexecutor))}))}const s=new fe(e.createChild(n),this._providedEnv,this._executeCloseLastSubstream);s._input=this._input;const[r,i]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Tn(n)));this._activeSubexecutor=new tt(s,new de(e.upstreamExecutor,e.createChild,e.lastDone,i,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),st(r)&&(this._activeSubexecutor=new Dt(r.value,this._activeSubexecutor))},n=>{if(e.activeChildExecutors.some(i=>i!==void 0)){const i=new ye(e.upstreamExecutor,e.lastDone,[void 0,...e.activeChildExecutors],e.upstreamExecutor.getDone(),e.combineChildResults,e.combineWithChildResult,e.onPull);if(this._closeLastSubstream!==void 0){const c=this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(c),O(()=>this.replaceSubexecutor(i)))}this.replaceSubexecutor(i);return}const s=this._closeLastSubstream,r=this.finishSubexecutorWithCloseEffect(o(n,Ni(i=>e.combineWithChildResult(e.lastDone,i))),()=>s,i=>e.upstreamExecutor.close(i));return r===void 0?void 0:$n(r)})}drainChildExecutors(e){if(e.activeChildExecutors.length===0){const i=this._closeLastSubstream;return i!==void 0&&this.addFinalizer(()=>x(i)),this.finishSubexecutorWithCloseEffect(e.upstreamDone,()=>i,c=>e.upstreamExecutor.close(c))}const n=e.activeChildExecutors[0],s=e.activeChildExecutors.slice(1);if(n===void 0){const[i,c]=this.applyUpstreamPullStrategy(!0,s,e.onPull(sc(s.reduce((a,u)=>u!==void 0?a+1:a,0))));return this.replaceSubexecutor(new ye(e.upstreamExecutor,e.lastDone,c,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull)),st(i)?(this._emitted=i.value,kt()):void 0}const r=new ye(e.upstreamExecutor,e.lastDone,s,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull);this.replaceSubexecutor(new tt(n.childExecutor,r,n.onEmit))}}const Rt=t=>t!==void 0?t:b,$t=(t,e)=>o(ke(t,n=>z(n(e))),O(n=>o(xi(n),ni(()=>Ui))),p(n=>y(()=>n))),ln=(t,e,n)=>{const s=[t],r=()=>{const i=s.pop();if(i===void 0||i.upstream===void 0)return ci("Unexpected end of input for channel execution");const c=i.upstream.run();switch(c._tag){case Ge:{const a=i.onEmit(i.upstream.getEmit());return s.length===0?a===void 0?y(e):o(a,J({onFailure:n,onSuccess:e})):a===void 0?y(()=>r()):o(a,J({onFailure:n,onSuccess:()=>r()}))}case Ve:{const a=i.onDone(i.upstream.getDone());return s.length===0?a===void 0?y(e):o(a,J({onFailure:n,onSuccess:e})):a===void 0?y(()=>r()):o(a,J({onFailure:n,onSuccess:()=>r()}))}case $e:return s.push(i),o(i.onEffect(c.effect),Xt(a=>y(()=>{const u=i.onDone(B(a));return u===void 0?b:u})),J({onFailure:n,onSuccess:()=>r()}));case Je:return s.push(i),s.push(c),y(()=>r())}};return r()},rc=t=>o(Ks(t),Ut),Ks=t=>{const e=(n,s,r)=>ai(I(()=>new fe(t,void 0,Q)),i=>y(()=>o(it(i.run(),i),ts(n),P(w(n)),wn(w(s)))),(i,c)=>{const a=i.close(c);return a===void 0?b:en(a,u=>Gi(r,Z(u)))});return Zt(n=>p(si,s=>o(ii([Yi(s,oi),W(),W()]),p(([r,i,c])=>o(pe(n(e(i,c,r))),p(a=>o(ri(()=>ee(c,void 0)),P(n(w(i))),wn(eo(a)))))))))},it=(t,e)=>{const n=t;switch(n._tag){case $e:return o(n.effect,p(()=>it(e.run(),e)));case Ge:return it(e.run(),e);case Ve:return y(()=>e.getDone());case Je:return ln(n,()=>it(e.run(),e),Z)}},Vs="Done",ic="Await",oc="effect/ChannelMergeDecision",cc=Symbol.for(oc),Gs={[cc]:{_R:t=>t,_E0:t=>t,_Z0:t=>t,_E:t=>t,_Z:t=>t}},ac=t=>{const e=Object.create(Gs);return e._tag=Vs,e.effect=t,e},Kt=t=>{const e=Object.create(Gs);return e._tag=ic,e.f=t,e},Js="BothRunning",Ys="LeftDone",Zs="RightDone",uc="effect/ChannelMergeState",An=Symbol.for(uc),hn={[An]:An},Tt=(t,e)=>{const n=Object.create(hn);return n._tag=Js,n.left=t,n.right=e,n},Ln=t=>{const e=Object.create(hn);return e._tag=Ys,e.f=t,e},xn=t=>{const e=Object.create(hn);return e._tag=Zs,e.f=t,e},Xs="BackPressure",er="BufferSliding",lc="effect/ChannelMergeStrategy",zn=Symbol.for(lc),tr={[zn]:zn},hc=t=>{const e=Object.create(tr);return e._tag=Xs,e},dc=t=>{const e=Object.create(tr);return e._tag=er,e},fc=h(2,(t,{onBackPressure:e,onBufferSliding:n})=>{switch(t._tag){case Xs:return e();case er:return n()}}),be="Empty",Le="Emit",xe="Error",ze="Done",nr=t=>({_tag:be,notifyProducer:t}),At=t=>({_tag:Le,notifyConsumers:t}),pc=t=>({_tag:xe,cause:t}),mc=t=>({_tag:ze,done:t});class _c{constructor(e){l(this,"ref");this.ref=e}awaitRead(){return he(Te(this.ref,e=>e._tag===be?[w(e.notifyProducer),e]:[b,e]))}get close(){return ui(e=>this.error(li(e)))}done(e){return he(Te(this.ref,n=>{switch(n._tag){case be:return[w(n.notifyProducer),n];case Le:return[ke(n.notifyConsumers,s=>ee(s,Fe(e)),{discard:!0}),mc(e)];case xe:return[Se,n];case ze:return[Se,n]}}))}emit(e){return p(W(),n=>he(Te(this.ref,s=>{switch(s._tag){case be:return[w(s.notifyProducer),s];case Le:{const r=s.notifyConsumers[0],i=s.notifyConsumers.slice(1);if(r!==void 0)return[ee(r,Ue(e)),i.length===0?nr(n):At(i)];throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues")}case xe:return[Se,s];case ze:return[Se,s]}})))}error(e){return he(Te(this.ref,n=>{switch(n._tag){case be:return[w(n.notifyProducer),n];case Le:return[ke(n.notifyConsumers,s=>ss(s,e),{discard:!0}),pc(e)];case xe:return[Se,n];case ze:return[Se,n]}}))}get take(){return this.takeWith(e=>B(rs(e,Fe)),e=>q(e),e=>fs(Ue(e)))}takeWith(e,n,s){return p(W(),r=>he(Te(this.ref,i=>{switch(i._tag){case be:return[P(ee(i.notifyProducer,void 0),at(w(r),{onFailure:e,onSuccess:U({onLeft:s,onRight:n})})),At([r])];case Le:return[at(w(r),{onFailure:e,onSuccess:U({onLeft:s,onRight:n})}),At([...i.notifyConsumers,r])];case xe:return[x(e(i.cause)),i];case ze:return[x(s(i.done)),i]}})))}}const sr=()=>o(W(),p(t=>ns(nr(t))),O(t=>new _c(t))),dt=h(2,(t,e)=>Ho(t,e,()=>{},()=>{})),rr=t=>{const e=le({onInput:()=>e,onFailure:F,onDone:He});return T(t,e)},ir=h(2,(t,e)=>Ko(t,()=>e)),gc=t=>m(t,Q),dn=t=>V(t.takeWith(F,e=>m(_(e),()=>dn(t)),He)),or=h(2,(t,e)=>m(t,n=>Bs(()=>e(n)))),St=h(2,(t,e)=>{const n=Re({onInput:s=>m(_(e(s)),()=>n),onFailure:te,onDone:ce});return T(t,n)}),Sc=h(3,(t,e,n)=>o(Ne(function*(s){const r=yield*s(Me(on(n),u=>Be(u))),i=yield*s(W()),c=n===Number.POSITIVE_INFINITY?u=>Q:(yield*s(cs(n))).withPermits,a=yield*s(Ie(t));return yield*s(J(a,{onFailure:u=>$(r,Z(u)),onSuccess:u=>U(u,{onLeft:d=>{const E=c(n);return P(ut(E(b)),Mt($(r,x(Fe(d)))))},onRight:d=>Ne(function*(E){const v=yield*E(W()),D=yield*E(W());yield*E(Mt($(r,O(w(v),Ue)))),yield*E(ee(D,void 0),P(o(Zt(k=>o(z(k(w(i))),fi(z(k(e(d)))),p(ne=>y(()=>ne)))),en(k=>ss(i,k)),ts(v))),c(1),pe),yield*E(w(D))})})}),pi,ut,pe),r}),O(s=>{const r=V(at(he(jt(s)),{onFailure:F,onSuccess:U({onLeft:ce,onRight:i=>m(_(i),()=>r)})}));return r}),pn)),Ec=t=>e=>bc(t)(e,mi),bc=({bufferSize:t=16,concurrency:e,mergeStrategy:n=hc()})=>(s,r)=>o(Ne(function*(i){const c=e==="unbounded"?Number.MAX_SAFE_INTEGER:e,a=yield*i(sr()),u=dn(a),d=yield*i(Me(on(t),C=>Be(C))),E=yield*i(Me(ys(),C=>Be(C))),v=yield*i(ns(M())),D=yield*i(W()),k=(yield*i(cs(c))).withPermits,ne=yield*i(Ie(s)),G=C=>o(p(C,U({onLeft:f=>x(j(f)),onRight:f=>we($(d,x(Ue(f))),M())})),Ei(st),p(f=>bi(v,_e({onNone:()=>j(f.value),onSome:H=>j(r(H,f.value))}))),Xt(f=>as(f)?Z(f):o($(d,Z(f)),P(ee(D,void 0)),Mt)));return yield*i(J(ne,{onFailure:C=>o($(d,Z(C)),P(x(!1))),onSuccess:U({onLeft:C=>is(w(D),k(c)(b),{onSelfDone:(f,H)=>we(Pe(H),!1),onOtherDone:(f,H)=>P(Pe(H),o(_i(v),p(_e({onNone:()=>$(d,x(Fe(C))),onSome:ge=>$(d,x(Fe(r(ge,C))))})),we(!1)))}),onRight:C=>fc(n,{onBackPressure:()=>Ne(function*(f){const H=yield*f(W()),ge=o(u,T(C),Ie,p(yt=>Ot(G(yt),w(D))),Ut);return yield*f(ee(H,void 0),P(ge),k(1),pe),yield*f(w(H)),!(yield*f(Pn(D)))}),onBufferSliding:()=>Ne(function*(f){const H=yield*f(W()),ge=yield*f(W()),En=yield*f(Io(E));yield*f(jt(E),p(wt=>ee(wt,void 0)),gi(()=>En>=c)),yield*f($(E,H));const yt=o(u,T(C),Ie,p(wt=>o(G(wt),Ot(w(D)),Ot(w(H)))),Ut);return yield*f(ee(ge,void 0),P(yt),k(1),pe),yield*f(w(ge)),!(yield*f(Pn(D)))})})})}),Si(Q),pe),[d,a]}),O(([i,c])=>{const a=o(jt(i),he,at({onFailure:F,onSuccess:U({onLeft:ce,onRight:u=>m(_(u),()=>a)})}),V);return Ws(a,c)}),pn),cr=h(3,(t,e,n)=>Ec(n)(St(t,e))),ar=h(2,(t,e)=>pn(p(sr(),n=>{const s=dn(n);return O(Nt(Ie(T(s,t)),Ie(T(s,e.other))),([r,i])=>{const c=(u,d,E)=>(v,D,k)=>{const ne=G=>{const C=G;return C._tag===Vs?x(R(P(Pe(d),C.effect))):O(Xi(d),Y({onFailure:f=>R(C.f(B(f))),onSuccess:U({onLeft:f=>R(C.f(q(f))),onRight:f=>Et(_(f),a(k(C.f)))})}))};return Y(u,{onFailure:G=>ne(v(B(G))),onSuccess:U({onLeft:G=>ne(v(q(G))),onRight:G=>x(m(_(G),()=>m(R(nt(E)),C=>a(D(C,d)))))})})},a=u=>{switch(u._tag){case Js:{const d=ut(Dn(u.left)),E=ut(Dn(u.right));return V(is(d,E,{onSelfDone:(v,D)=>P(Pe(D),c(v,u.right,r)(e.onSelfDone,Tt,k=>Ln(k))),onOtherDone:(v,D)=>P(Pe(D),c(v,u.left,i)(e.onOtherDone,(k,ne)=>Tt(ne,k),k=>xn(k)))}))}case Ys:return V(O(z(i),Y({onFailure:d=>R(u.f(B(d))),onSuccess:U({onLeft:d=>R(u.f(q(d))),onRight:d=>m(_(d),()=>a(Ln(u.f)))})})));case Zs:return V(O(z(r),Y({onFailure:d=>R(u.f(B(d))),onSuccess:U({onLeft:d=>R(u.f(q(d))),onRight:d=>m(_(d),()=>a(xn(u.f)))})})))}};return o(R(_t(nt(r),nt(i),(u,d)=>Tt(u,d))),m(a),Ws(n))})}))),fn=h(2,(t,e)=>Ke(()=>{let n;const s=Re({onInput:i=>m(_(i),()=>s),onFailure:i=>(n=Pc(i),F(es(n))),onDone:ce}),r=le({onInput:i=>o(_(i),m(()=>r)),onFailure:i=>hi(i)&&Oc(i.defect)&&di(i.defect,n)?te(i.defect.error):F(i),onDone:ce});return T(T(T(t,s),e),r)})),ur=t=>m(t,()=>ur(t)),Cc=t=>rc(rr(t)),lr=t=>V(Zt(e=>O(Zi(),n=>Bo(en(e(Ji(n)(t)),s=>Fn(n,B(s))),(s,r)=>Fn(n,r))))),Ie=t=>O(Me(I(()=>new fe(t,void 0,Q)),(e,n)=>{const s=e.close(n);return s===void 0?b:s}),e=>y(()=>Vt(e.run(),e))),Vt=(t,e)=>{const n=t;switch(n._tag){case Ve:return Y(e.getDone(),{onFailure:Z,onSuccess:s=>x(Fe(s))});case Ge:return x(Ue(e.getEmit()));case $e:return o(n.effect,p(()=>Vt(e.run(),e)));case Je:return ln(n,()=>Vt(e.run(),e),s=>Z(s))}},V=t=>gc(R(t)),pn=t=>Qo(lr(t),(e,n)=>e,(e,n)=>e),yc=(...t)=>Ye(zt(t)),Ye=t=>hr(0,t.length,t),hr=(t,e,n)=>t===e?N:o(_(o(n,os(t))),m(()=>hr(t+1,e,n))),wc=h(t=>qs(t[1]),(t,e,n)=>n?.concurrent?ar(t,{other:e,onSelfDone:s=>Kt(r=>y(()=>In(s,r))),onOtherDone:s=>Kt(r=>y(()=>In(r,s)))}):m(t,s=>or(e,r=>[s,r]))),Et=h(t=>qs(t[1]),(t,e,n)=>n?.concurrent?or(wc(t,e,{concurrent:!0}),s=>s[1]):m(t,()=>e)),Gt=Symbol.for("effect/Channel/ChannelException"),Pc=t=>({_tag:"ChannelException",[Gt]:Gt,error:t}),Oc=t=>mt(t,Gt),Ic=Symbol.for("effect/Sink"),vc={_R:t=>t,_E:t=>t,_In:t=>t,_L:t=>t,_Z:t=>t};var Qa;class mn{constructor(e){l(this,"channel");l(this,Qa,vc);this.channel=e}pipe(){return ae(this,arguments)}}Qa=Ic;const kc=t=>new mn(Ke(()=>_n(t()))),Fc=(t,e,n)=>kc(()=>new mn(dr(t,e,n))),dr=(t,e,n)=>e(t)?Re({onInput:s=>dr(n(t,s),e,n),onFailure:te,onDone:()=>ce(t)}):ce(t),Dc=(t,e)=>Fc(t,Ci,e),Rc=t=>new mn(R(t)),$c=()=>Dc(M(),(t,e)=>yi(wi(e),()=>t)),_n=t=>Qe(t)?_n(Rc(t)):t.channel,Tc=ac,Ac=Kt,Lc="Left",xc="Right",zc="Both",Nc="Either",Uc={_tag:Lc},Mc={_tag:xc},fr={_tag:zc},qc={_tag:Nc},Wc=t=>{switch(t){case"left":return Uc;case"right":return Mc;case"both":return fr;case"either":return qc;default:return t}},Bc=fr,jc="effect/Take",Qc=Symbol.for(jc),Hc={_E:t=>t,_A:t=>t};var Ha;class bt{constructor(e){l(this,"exit");l(this,Ha,Hc);this.exit=e}pipe(){return ae(this,arguments)}}Ha=Qc;const Nn=t=>new bt(q(t)),Un=new bt(fs(M())),Kc=t=>new bt(B(o(t,rs(j)))),Vc=t=>new bt(q(ue(t))),Gc=()=>us(M()),Jc=t=>ls(Z(t),j),Yc="effect/Stream",pr=Symbol.for(Yc),Zc={_R:t=>t,_E:t=>t,_A:t=>t};var Ka;class S{constructor(e){l(this,"channel");l(this,Ka,Zc);this.channel=e}pipe(){return ae(this,arguments)}}Ka=pr;const gn=t=>mt(t,pr)||Qe(t),mr=4096,Xc=h(2,(t,e)=>ea(t,n=>U(Xn(n),{onLeft:e,onRight:ia}))),ea=h(2,(t,e)=>new S(o(g(t),jo(n=>g(e(n)))))),ta=t=>o(t,pa(ue)),na=t=>Ze(Ii(t)),sa=new S(_(je())),ra=h(2,(t,e)=>new S(o(g(t),ir(e)))),ia=t=>Ze(Z(t)),Sn=h(t=>gn(t[0]),(t,e,n)=>{const s=n?.bufferSize??16;return n?.switch?Jt(n?.concurrency,()=>Mn(t,1,s,e),r=>Mn(t,r,s,e)):Jt(n?.concurrency,()=>new S(dt(g(t),r=>o(r,ds(i=>g(e(i))),Fi(N,(i,c)=>o(i,Et(c)))))),r=>new S(o(g(t),dt(Ye),cr(i=>g(e(i)),n))))}),Jt=(t,e,n)=>{switch(t){case void 0:return e();case"unbounded":return n(Number.MAX_SAFE_INTEGER);default:return t>1?n(t):e()}},Mn=h(4,(t,e,n,s)=>new S(o(g(t),dt(Ye),cr(r=>g(s(r)),{concurrency:e,mergeStrategy:dc(),bufferSize:n})))),oa=h(t=>gn(t[0]),(t,e)=>Sn(t,Q,e)),ca=t=>{const e=le({onInput:n=>m(Ye(n),()=>e),onFailure:F,onDone:()=>N});return new S(o(g(t),T(e)))},aa=t=>{const e=(s,r)=>{const[i,c]=o(s,Di(u=>!qt(u))),a=o($i(c),_e({onNone:()=>r,onSome:Y({onFailure:u=>_e(Ri(u),{onNone:()=>N,onSome:F}),onSuccess:()=>N})}));return o(_(o(i,Ti(u=>qt(u)?j(u.value):M()))),m(()=>a))},n=le({onInput:s=>e(s,n),onFailure:s=>F(s),onDone:()=>N});return new S(o(g(t),T(n)))},_r=t=>ca(aa(o(t,ft(e=>e.exit)))),g=t=>{if("channel"in t)return t.channel;if(Qe(t))return g(Ze(t));throw new TypeError("Expected a Stream.")},ua=t=>new S(Gn(t)?N:_(t)),Ze=t=>o(t,ls(j),la),la=t=>new S(V(hs(t,{onFailure:_e({onNone:()=>N,onSome:te}),onSuccess:e=>_(ue(e))}))),gr=(t,e)=>o(ko(t,1,e?.maxChunkSize??mr),Xt(n=>o(vo(t),p(s=>s&&as(n)?Gc():Jc(n)))),Ca,e?.shutdown?ra(Be(t)):Q),ha=h(2,(t,e)=>o(t,Ea(e),ta)),ft=h(2,(t,e)=>new S(o(g(t),St(ds(e))))),da=h(3,(t,e,n)=>{const s=r=>Re({onInput:i=>{const[c,a]=Pi(i,r,n);return m(_(a),()=>s(c))},onFailure:te,onDone:()=>N});return new S(o(g(t),T(s(e))))}),fa=h(3,(t,e,n)=>Ct(()=>{const s=r=>Re({onInput:i=>o(y(()=>{const c=[],a=u=>I(()=>{c.push(u)});return o(i,vi(r,(u,d)=>o(n(u,d),p(([E,v])=>o(a(v),we(E))))),hs({onFailure:u=>c.length!==0?Et(_(De(c)),te(u)):te(u),onSuccess:u=>m(_(De(c)),()=>s(u))}))}),V),onFailure:te,onDone:()=>N});return new S(o(g(t),fn(s(e))))})),pa=h(2,(t,e)=>new S(o(g(t),St(e)))),Yt=h(2,(t,e)=>{const n=s=>{const r=s.next();if(r.done)return le({onInput:i=>n(i[Symbol.iterator]()),onFailure:F,onDone:He});{const i=r.value;return V(O(e(i),c=>m(_(ue(c)),()=>n(s))))}};return new S(o(g(t),T(Ke(()=>n(je()[Symbol.iterator]())))))}),ma=h(3,(t,e,n)=>new S(o(g(t),dt(Ye),Sc(n,e),St(ue)))),_a=h(t=>gn(t[1]),(t,e,n)=>ga(t,e,{onSelf:Q,onOther:Q,haltStrategy:n?.haltStrategy})),ga=h(3,(t,e,n)=>{const s=n.haltStrategy?Wc(n.haltStrategy):Bc,r=i=>c=>i||!qt(c)?Tc(y(()=>c)):Ac(a=>y(()=>a));return new S(ar(g(ft(t,n.onSelf)),{other:g(ft(e,n.onOther)),onSelfDone:r(s._tag==="Either"||s._tag==="Left"),onOtherDone:r(s._tag==="Either"||s._tag==="Right")}))}),Sa=(t,e,n=mr)=>Ct(()=>{if(t>e)return sa;const s=(r,i,c)=>{const a=i-r+1;return a>c?o(_(On(r,r+c-1)),m(()=>s(r+c,i,c))):_(On(r,r+a-1))};return new S(s(t,e,n))}),Ea=h(2,(t,e)=>Ct(()=>{const n=Math.max(e,1),s=ot(new ba(n),n);return new S(o(g(t),T(s)))})),ot=(t,e)=>le({onInput:n=>{if(n.length===e&&t.isEmpty())return m(_(n),()=>ot(t,e));if(n.length>0){const s=[];let r,i=0;for(;i<n.length;){for(;i<n.length&&r===void 0;)r=t.write(o(n,os(i))),i=i+1;r!==void 0&&(s.push(r),r=void 0)}return m(yc(...s),()=>ot(t,e))}return Ke(()=>ot(t,e))},onFailure:n=>Et(t.emitIfNotEmpty(),F(n)),onDone:()=>t.emitIfNotEmpty()});class ba{constructor(e){l(this,"n");l(this,"builder",[]);l(this,"pos",0);this.n=e}isEmpty(){return this.pos===0}write(e){if(this.builder.push(e),this.pos+=1,this.pos===this.n){const n=De(this.builder);return this.builder=[],this.pos=0,n}}emitIfNotEmpty(){return this.pos!==0?_(De(this.builder)):N}}const Ca=t=>Fa(t,e=>o(O(e,n=>j([n,e])),Ai(_e({onNone:()=>x(M()),onSome:us})))),ya=t=>new S(ur(_(ue(t)))),wa=h(2,(t,e)=>o(g(t),fn(_n(e)),Cc)),Pa=t=>o(t,wa($c())),Oa=t=>new S(ir(lr(o(t,O(ue))),b)),Ia=t=>ua(ue(t)),Ct=t=>new S(Ke(()=>g(t()))),va=h(2,(t,e)=>{if(!Number.isInteger(e))return na(Oi(`${e} must be an integer`));const n=s=>Re({onInput:r=>{const i=o(r,ki(Math.min(s,Number.POSITIVE_INFINITY))),c=Math.max(0,s-i.length);return c>0?o(_(i),m(()=>n(c))):_(i)},onFailure:te,onDone:He});return new S(o(g(t),fn(0<e?n(e):N)))}),ka=h(2,(t,e)=>Yt(t,n=>we(e(n),n))),Fa=(t,e)=>Ct(()=>{const n=s=>V(O(e(s),_e({onNone:()=>N,onSome:([r,i])=>m(_(r),()=>n(i))})));return new S(n(t))}),Da=t=>oa(Oa(t)),Ra="effect/GroupBy",Sr=Symbol.for(Ra),$a={_R:t=>t,_E:t=>t,_K:t=>t,_V:t=>t},Ta=t=>mt(t,Sr),Aa=h(t=>Ta(t[0]),(t,e,n)=>Sn(t.grouped,([s,r])=>e(s,_r(gr(r,{shutdown:!0}))),{concurrency:"unbounded",bufferSize:n?.bufferSize??16})),La=t=>({[Sr]:$a,pipe(){return ae(this,arguments)},grouped:t}),xa=h(t=>typeof t[0]!="function",(t,e,n)=>n?.key?Aa(za(t,n.key,{bufferSize:n.bufferSize}),(s,r)=>Yt(r,e)):Jt(n?.concurrency,()=>Yt(t,e),s=>n?.unordered?Sn(t,r=>Ze(e(r)),{concurrency:s}):ma(t,s,e))),za=h(t=>typeof t[0]!="function",(t,e,n)=>{const s=(r,i)=>le({onInput:c=>m(R(ke(Na(c,e),([a,u])=>{const d=r.get(a);return d===void 0?o(on(n?.bufferSize??16),p(E=>o(I(()=>{r.set(a,E)}),P($(i,Vc([a,E]))),P(o($(E,Nn(u)),It(v=>vt(v)?j(b):M())))))):It($(d,Nn(u)),E=>vt(E)?j(b):M())},{discard:!0})),()=>s(r,i)),onFailure:c=>R($(i,Kc(c))),onDone:()=>o(R(o(ke(r.entries(),([c,a])=>o($(a,Un),It(u=>vt(u)?j(b):M())),{discard:!0}),P($(i,Un)))))});return La(Da(o(I(()=>new Map),p(r=>o(Me(ys(),i=>Be(i)),p(i=>o(t,g,T(s(r,i)),rr,Ks,pe,we(_r(gr(i,{shutdown:!0}))))))))))}),Na=h(2,(t,e)=>{const n=[],s=t[Symbol.iterator](),r=new Map;let i;for(;(i=s.next())&&!i.done;){const c=i.value,a=e(c);if(r.has(a))r.get(a).push(c);else{const u=[c];n.push([a,u]),r.set(a,u)}}return De(n.map(c=>[c[0],De(c[1])]))}),Ya=Xc,Za=Ze,Xa=ha,eu=ft,tu=da,nu=fa,su=xa,ru=_a,iu=Sa,ou=ya,cu=Pa,au=Ia,uu=va,lu=ka;export{nu as a,ou as b,Ya as c,tu as d,iu as e,ru as f,Xa as g,Za as h,uu as i,su as j,eu as m,cu as r,au as s,lu as t};
