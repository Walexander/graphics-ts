var Er=Object.defineProperty;var br=(t,e,n)=>e in t?Er(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var l=(t,e,n)=>(br(t,typeof e!="symbol"?e+"":e,n),n);import{aC as Cr,aD as yr,aE as wr,aF as Pr,aG as Or,aH as Ir,aI as vr,aJ as kr,aK as Fr,aL as Dr,aM as Rr,aN as $r,aO as Wn,aP as qn,aQ as Bn,aR as ae,aS as h,au as je,aT as pt,aU as jn,aV as Tr,aW as Ar,aX as Lr,aY as xr,aZ as zr,a_ as Nr,a$ as Ur,b0 as Mr,b1 as Wr,D as o,b2 as ve,b3 as ie,b4 as ct,b5 as qr,b6 as Br,b7 as Qn,b8 as X,b9 as se,ba as jr,bb as re,bc as K,bd as M,be as j,bf as Qr,bg as Lt,bh as Hr,bi as Hn,bj as Kr,bk as Vr,bl as Gr,bm as Kn,bn as Vn,bo as xt,bp as bn,bq as Jr,br as Yr,bs as Gn,bt as Jn,bu as Yn,bv as zt,bw as Pt,_ as Cn,bx as Zr,by as Zn,bz as Xr,bA as ei,bB as U,bC as Xn,bD as Q,bE as mt,bF as Qe,Z as b,bG as ti,bH as _t,bI as z,at as I,p as yn,bJ as J,m as P,l as p,bK as y,bL as nt,bM as es,bN as Xe,bO as et,H as O,z as Nt,S as ke,a4 as x,bP as st,V as ni,bQ as Zt,bR as si,bS as pe,bT as ri,bU as w,bV as wn,a as ii,bW as oi,bX as q,bY as ci,bZ as Xt,b_ as Ut,b$ as ai,c0 as ts,c1 as en,c2 as Z,c3 as ee,ak as ns,c4 as he,c5 as Te,c6 as ui,c7 as Se,c8 as Fe,c9 as Ue,ca as ss,cb as rs,cc as at,cd as li,ce as Me,cf as ut,cg as is,ch as hi,ci as di,a3 as os,aj as Ne,cj as cs,ck as Mt,cl as fi,cm as pi,cn as mi,ad as we,am as _i,co as _e,cp as Ot,cq as Pn,cr as gi,cs as Si,ct as Ei,cu as bi,cv as as,cw as Ci,cx as yi,cy as wi,Y as ue,a0 as us,cz as ls,cA as hs,cB as ds,cC as Pi,cD as Oi,cE as Ii,cF as vi,cG as De,cH as On,cI as ki,cJ as Fi,cK as Di,cL as Ri,cM as $i,cN as Ti,a1 as Ai,cO as Li,cP as xi,cQ as zi,cR as Ni,cS as It,cT as vt}from"./Shape-9d40d40f.js";const Ui=wr,Wt=Cr,Mi=Pr,Wi=Or,fs=Dr,B=Ir,qi=Rr,Y=yr,W=vr,Bi=kr,In=$r,We=Fr,vn=Symbol.for("effect/MutableList"),ji={[vn]:vn,[Symbol.iterator](){let t=!1,e=this.head;return{next(){if(t)return this.return();if(e==null)return t=!0,this.return();const n=e.value;return e=e.next,{done:t,value:n}},return(n){return t||(t=!0),{done:!0,value:n}}}},toString(){return Wn(this.toJSON())},toJSON(){return{_id:"MutableList",values:Array.from(this).map(qn)}},[Bn](){return this.toJSON()},pipe(){return ae(this,arguments)}};class Qi{constructor(e){l(this,"value");l(this,"removed",!1);l(this,"prev");l(this,"next");this.value=e}}const Hi=()=>{const t=Object.create(ji);return t.head=void 0,t.tail=void 0,t._length=0,t},ps=t=>tn(t)===0,tn=t=>t._length,Ki=h(2,(t,e)=>{const n=new Qi(e);return t.head===void 0&&(t.head=n),t.tail===void 0||(t.tail.next=n,n.prev=t.tail),t.tail=n,t._length+=1,t}),Vi=t=>{const e=t.head;if(e!==void 0)return Gi(t,e),e.value},Gi=(t,e)=>{e.removed||(e.removed=!0,e.prev!==void 0&&e.next!==void 0?(e.prev.next=e.next,e.next.prev=e.prev):e.prev!==void 0?(t.tail=e.prev,e.prev.next=void 0):e.next!==void 0?(t.head=e.next,e.next.prev=void 0):(t.tail=void 0,t.head=void 0),t._length>0&&(t._length-=1))},kn=Symbol.for("effect/MutableQueue"),L=Symbol.for("effect/mutable/MutableQueue/Empty"),Ji={[kn]:kn,[Symbol.iterator](){return Array.from(this.queue)[Symbol.iterator]()},toString(){return Wn(this.toJSON())},toJSON(){return{_id:"MutableQueue",values:Array.from(this).map(qn)}},[Bn](){return this.toJSON()},pipe(){return ae(this,arguments)}},ms=t=>{const e=Object.create(Ji);return e.queue=Hi(),e.capacity=t,e},Yi=t=>ms(t),nn=()=>ms(void 0),sn=t=>tn(t.queue),qt=t=>ps(t.queue),Zi=t=>t.capacity===void 0?1/0:t.capacity,qe=h(2,(t,e)=>{const n=tn(t.queue);return t.capacity!==void 0&&n===t.capacity?!1:(Ki(e)(t.queue),!0)}),_s=h(2,(t,e)=>{const n=e[Symbol.iterator]();let s,r=je(),i=!0;for(;i&&(s=n.next())&&!s.done;)i=qe(s.value)(t);for(;s!=null&&!s.done;)r=pt(s.value)(r),s=n.next();return jn(r)}),oe=h(2,(t,e)=>ps(t.queue)?e:Vi(t.queue)),rn=h(2,(t,e)=>{let n=je(),s=0;for(;s<e;){const r=oe(L)(t);if(r===L)break;n=pt(r)(n),s+=1}return jn(n)}),Xi=zr,Fn=Tr,eo=Ar,to=Lr,no=xr,so=Wr,ro=Nr,Pe=Ur,Dn=Mr,io="effect/QueueEnqueue",oo=Symbol.for(io),co="effect/QueueDequeue",ao=Symbol.for(co),uo="effect/QueueStrategy",gs=Symbol.for(uo),Ss={_A:t=>t},lo={_In:t=>t},ho={_Out:t=>t};var Qa,Ha;class fo{constructor(e,n,s,r,i){l(this,"queue");l(this,"takers");l(this,"shutdownHook");l(this,"shutdownFlag");l(this,"strategy");l(this,Qa,lo);l(this,Ha,ho);this.queue=e,this.takers=n,this.shutdownHook=s,this.shutdownFlag=r,this.strategy=i}pipe(){return ae(this,arguments)}capacity(){return this.queue.capacity()}get size(){return se(()=>jr(this.unsafeSize(),()=>re))}unsafeSize(){return K(this.shutdownFlag)?M():j(this.queue.length()-sn(this.takers)+this.strategy.surplusSize())}get isEmpty(){return ct(this.size,e=>e<=0)}get isFull(){return ct(this.size,e=>e>=this.capacity())}get shutdown(){return Qr(Lt(e=>(o(this.shutdownFlag,Hr(!0)),o(Kn(Oe(this.takers),n=>Vn(n,e.id()),!1),Gr(this.strategy.shutdown),Kr(Vr(this.shutdownHook,void 0)),Hn))))}get isShutdown(){return ie(()=>K(this.shutdownFlag))}get awaitShutdown(){return xt(this.shutdownHook)}isActive(){return!K(this.shutdownFlag)}unsafeOffer(e){if(K(this.shutdownFlag))return!1;let n;if(this.queue.length()===0){const r=o(this.takers,oe(L));r!==L?(me(r,e),n=!0):n=!1}else n=!1;if(n)return!0;const s=this.queue.offer(e);return Ce(this.strategy,this.queue,this.takers),s}offer(e){return se(()=>{if(K(this.shutdownFlag))return re;let n;if(this.queue.length()===0){const r=o(this.takers,oe(L));r!==L?(me(r,e),n=!0):n=!1}else n=!1;if(n)return X(!0);const s=this.queue.offer(e);return Ce(this.strategy,this.queue,this.takers),s?X(!0):this.strategy.handleSurplus([e],this.queue,this.takers,this.shutdownFlag)})}offerAll(e){return se(()=>{if(K(this.shutdownFlag))return re;const n=bn(e),s=this.queue.length()===0?bn(ko(this.takers,n.length)):Jr,[r,i]=o(n,Yr(s.length));for(let a=0;a<s.length;a++){const u=s[a],d=r[a];me(u,d)}if(i.length===0)return X(!0);const c=this.queue.offerAll(i);return Ce(this.strategy,this.queue,this.takers),Gn(c)?X(!0):this.strategy.handleSurplus(c,this.queue,this.takers,this.shutdownFlag)})}get take(){return Lt(e=>{if(K(this.shutdownFlag))return re;const n=this.queue.poll(L);if(n!==L)return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),X(n);{const s=Jn(e.id());return o(se(()=>(o(this.takers,qe(s)),Ce(this.strategy,this.queue,this.takers),K(this.shutdownFlag)?re:xt(s))),Yn(()=>ie(()=>Fo(this.takers,s))))}})}get takeAll(){return se(()=>K(this.shutdownFlag)?re:ie(()=>{const e=this.queue.pollUpTo(Number.POSITIVE_INFINITY);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),zt(e)}))}takeUpTo(e){return se(()=>K(this.shutdownFlag)?re:ie(()=>{const n=this.queue.pollUpTo(e);return this.strategy.unsafeOnQueueEmptySpace(this.queue,this.takers),zt(n)}))}takeBetween(e,n){return se(()=>Es(this,e,n,je()))}}Qa=oo,Ha=ao;const Es=(t,e,n,s)=>n<e?X(s):o(yo(t,n),ve(r=>{const i=e-r.length;return i===1?o(Bt(t),ct(c=>o(s,Pt(r),Cn(c)))):i>1?o(Bt(t),ve(c=>Es(t,i-1,n-r.length-1,o(s,Pt(r),Cn(c))))):X(o(s,Pt(r)))})),po=t=>o(ie(()=>Yi(t)),ve(e=>bs(Cs(e),Po()))),mo=()=>o(ie(()=>nn()),ve(t=>bs(Cs(t),Oo()))),_o=(t,e,n,s,r)=>new fo(t,e,n,s,r),bs=(t,e)=>o(Br(),ct(n=>_o(t,nn(),n,qr(!1),e)));class go{constructor(e){l(this,"mutable");this.mutable=e}poll(e){return oe(this.mutable,e)}pollUpTo(e){return rn(this.mutable,e)}offerAll(e){return _s(this.mutable,e)}offer(e){return qe(this.mutable,e)}capacity(){return Zi(this.mutable)}length(){return sn(this.mutable)}}const Cs=t=>new go(t),So=t=>t.size,Eo=t=>t.isShutdown,bo=t=>t.shutdown,Co=h(2,(t,e)=>t.offer(e)),Bt=t=>t.take,yo=h(2,(t,e)=>t.takeUpTo(e)),wo=h(3,(t,e,n)=>t.takeBetween(e,n)),Po=()=>new Io,Oo=()=>new vo;var Ka;class Io{constructor(){l(this,Ka,Ss);l(this,"putters",nn())}surplusSize(){return sn(this.putters)}onCompleteTakersWithEmptyQueue(e){for(;!qt(this.putters)&&!qt(e);){const n=oe(e,void 0),s=oe(this.putters,void 0);s[2]&&me(s[1],!0),me(n,s[0])}}get shutdown(){return o(Zr,ve(e=>o(ie(()=>Oe(this.putters)),ve(n=>Kn(n,([s,r,i])=>i?o(Vn(r,e),Hn):Qn,!1)))))}handleSurplus(e,n,s,r){return Lt(i=>{const c=Jn(i.id());return o(se(()=>(this.unsafeOffer(e,c),this.unsafeOnQueueEmptySpace(n,s),Ce(this,n,s),K(r)?re:xt(c))),Yn(()=>ie(()=>this.unsafeRemove(c))))})}unsafeOnQueueEmptySpace(e,n){let s=!0;for(;s&&(e.capacity()===Number.POSITIVE_INFINITY||e.length()<e.capacity());){const r=o(this.putters,oe(L));if(r===L)s=!1;else{const i=e.offer(r[0]);i&&r[2]?me(r[1],!0):i||lt(this.putters,o(Oe(this.putters),pt(r))),Ce(this,e,n)}}}unsafeOffer(e,n){const s=Array.from(e);for(let r=0;r<s.length;r++){const i=s[r];r===s.length-1?o(this.putters,qe([i,n,!0])):o(this.putters,qe([i,n,!1]))}}unsafeRemove(e){lt(this.putters,o(Oe(this.putters),Zn(([,n])=>n!==e)))}}Ka=gs;var Va;class vo{constructor(){l(this,Va,Ss)}surplusSize(){return 0}get shutdown(){return Qn}onCompleteTakersWithEmptyQueue(){}handleSurplus(e,n,s,r){return X(!1)}unsafeOnQueueEmptySpace(e,n){}}Va=gs;const me=(t,e)=>Xr(t,X(e)),lt=(t,e)=>o(t,_s(e)),Oe=t=>o(t,rn(Number.POSITIVE_INFINITY)),ko=(t,e)=>o(t,rn(e)),Fo=(t,e)=>{lt(t,o(Oe(t),Zn(n=>e!==n)))},Ce=(t,e,n)=>{let s=!0;for(;s&&e.length()!==0;){const r=o(n,oe(L));if(r!==L){const i=e.poll(L);i!==L?(me(r,i),t.unsafeOnQueueEmptySpace(e,n)):lt(n,o(Oe(n),pt(r))),s=!0}else s=!1}s&&e.length()===0&&!qt(n)&&t.onCompleteTakersWithEmptyQueue(n)},on=po,ys=mo,Do=So,Ro=Eo,Be=bo,$=Co,jt=Bt,$o=wo,ws="Continue",To="Close",Ao="Yield",Lo="effect/ChannelChildExecutorDecision",Rn=Symbol.for(Lo),xo={[Rn]:Rn},Ps=t=>{const e=Object.create(xo);return e._tag=ws,e},rt="ContinuationK",zo="ContinuationFinalizer",Os=Symbol.for("effect/ChannelContinuation"),Is={_Env:t=>t,_InErr:t=>t,_InElem:t=>t,_InDone:t=>t,_OutErr:t=>t,_OutDone:t=>t,_OutErr2:t=>t,_OutElem:t=>t,_OutDone2:t=>t};var Ga;class cn{constructor(e,n){l(this,"onSuccess");l(this,"onHalt");l(this,"_tag",rt);l(this,Ga,Is);this.onSuccess=e,this.onHalt=n}onExit(e){return Ui(e)?this.onHalt(e.cause):this.onSuccess(e.value)}}Ga=Os;var Ja;class No{constructor(e){l(this,"finalizer");l(this,"_tag",zo);l(this,Ja,Is);this.finalizer=e}}Ja=Os;const vs="PullAfterNext",Uo="PullAfterAllEnqueued",Mo="effect/ChannelUpstreamPullStrategy",Wo=Symbol.for(Mo),qo={_A:t=>t},Bo={[Wo]:qo},ks=t=>{const e=Object.create(Bo);return e._tag=vs,e.emitSeparator=t,e},Fs="BracketOut",Ds="Bridge",an="ConcatAll",Rs="Emit",$s="Ensuring",Ts="Fail",un="Fold",As="FromEffect",Ls="PipeTo",jo="Provide",xs="Read",zs="Succeed",Ns="SucceedNow",Us="Suspend",Qo="effect/Channel",Ms=Symbol.for(Qo),Ho={_Env:t=>t,_InErr:t=>t,_InElem:t=>t,_InDone:t=>t,_OutErr:t=>t,_OutElem:t=>t,_OutDone:t=>t},A={[Ms]:Ho,pipe(){return ae(this,arguments)}},Ws=t=>mt(t,Ms)||Qe(t),Ko=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Fs,n.acquire=()=>t,n.finalizer=e,n}),Vo=h(2,(t,e)=>{const n=Object.create(A);return n._tag=un,n.channel=t,n.k=new cn(He,e),n}),Go=(t,e,n)=>{const s=Object.create(A);return s._tag=an,s.combineInners=e,s.combineAll=n,s.onPull=()=>ks(M()),s.onEmit=()=>Ps,s.value=()=>t,s.k=Q,s},Jo=h(4,(t,e,n,s)=>{const r=Object.create(A);return r._tag=an,r.combineInners=n,r.combineAll=s,r.onPull=()=>ks(M()),r.onEmit=()=>Ps,r.value=()=>t,r.k=e,r}),qs=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Ds,n.input=e,n.channel=t,n}),Yo=h(2,(t,e)=>{const n=Object.create(A);return n._tag=$s,n.channel=t,n.finalizer=e,n}),te=t=>F(ei(t)),F=t=>Zo(()=>t),Zo=t=>{const e=Object.create(A);return e._tag=Ts,e.error=t,e},m=h(2,(t,e)=>{const n=Object.create(A);return n._tag=un,n.channel=t,n.k=new cn(e,F),n}),R=t=>{const e=Object.create(A);return e._tag=As,e.effect=()=>t,e},T=h(2,(t,e)=>{const n=Object.create(A);return n._tag=Ls,n.left=()=>t,n.right=()=>e,n}),Re=t=>le({onInput:t.onInput,onFailure:e=>U(Xn(e),{onLeft:t.onFailure,onRight:F}),onDone:t.onDone}),le=t=>{const e=Object.create(A);return e._tag=xs,e.more=t.onInput,e.done=new cn(t.onDone,t.onFailure),e},He=t=>Bs(()=>t),ce=t=>{const e=Object.create(A);return e._tag=Ns,e.terminal=t,e},Ke=t=>{const e=Object.create(A);return e._tag=Us,e.channel=t,e},Bs=t=>{const e=Object.create(A);return e._tag=zs,e.evaluate=t,e},N=ce(void 0),_=t=>{const e=Object.create(A);return e._tag=Rs,e.out=t,e},Ve="Done",Ge="Emit",$e="FromEffect",Je="Read",Xo=Symbol.for("effect/ChannelState"),ec={_R:t=>t,_E:t=>t},gt={[Xo]:ec},Ee=()=>{const t=Object.create(gt);return t._tag=Ve,t},kt=()=>{const t=Object.create(gt);return t._tag=Ge,t},Ae=t=>{const e=Object.create(gt);return e._tag=$e,e.effect=t,e},Ft=(t,e,n,s)=>{const r=Object.create(gt);return r._tag=Je,r.upstream=t,r.onEffect=e,r.onEmit=n,r.onDone=s,r},ht=t=>t._tag===$e,tc=t=>ht(t)?t.effect:b,$n=t=>ht(t)?ti(t.effect):void 0,js="PullFromChild",Qt="PullFromUpstream",Ht="DrainChildExecutors",Qs="Emit";class tt{constructor(e,n,s){l(this,"childExecutor");l(this,"parentSubexecutor");l(this,"onEmit");l(this,"_tag",js);this.childExecutor=e,this.parentSubexecutor=n,this.onEmit=s}close(e){const n=this.childExecutor.close(e),s=this.parentSubexecutor.close(e);return n!==void 0&&s!==void 0?_t(z(n),z(s),(r,i)=>o(r,We(i))):n!==void 0?n:s!==void 0?s:void 0}enqueuePullFromChild(e){return this}}class de{constructor(e,n,s,r,i,c,a,u){l(this,"upstreamExecutor");l(this,"createChild");l(this,"lastDone");l(this,"activeChildExecutors");l(this,"combineChildResults");l(this,"combineWithChildResult");l(this,"onPull");l(this,"onEmit");l(this,"_tag",Qt);this.upstreamExecutor=e,this.createChild=n,this.lastDone=s,this.activeChildExecutors=r,this.combineChildResults=i,this.combineWithChildResult=c,this.onPull=a,this.onEmit=u}close(e){const n=this.upstreamExecutor.close(e),r=[...this.activeChildExecutors.map(i=>i!==void 0?i.childExecutor.close(e):void 0),n].reduce((i,c)=>i!==void 0&&c!==void 0?_t(i,z(c),(a,u)=>We(a,u)):i!==void 0?i:c!==void 0?z(c):void 0,void 0);return r}enqueuePullFromChild(e){return new de(this.upstreamExecutor,this.createChild,this.lastDone,[...this.activeChildExecutors,e],this.combineChildResults,this.combineWithChildResult,this.onPull,this.onEmit)}}class ye{constructor(e,n,s,r,i,c,a){l(this,"upstreamExecutor");l(this,"lastDone");l(this,"activeChildExecutors");l(this,"upstreamDone");l(this,"combineChildResults");l(this,"combineWithChildResult");l(this,"onPull");l(this,"_tag",Ht);this.upstreamExecutor=e,this.lastDone=n,this.activeChildExecutors=s,this.upstreamDone=r,this.combineChildResults=i,this.combineWithChildResult=c,this.onPull=a}close(e){const n=this.upstreamExecutor.close(e),r=[...this.activeChildExecutors.map(i=>i!==void 0?i.childExecutor.close(e):void 0),n].reduce((i,c)=>i!==void 0&&c!==void 0?_t(i,z(c),(a,u)=>We(a,u)):i!==void 0?i:c!==void 0?z(c):void 0,void 0);return r}enqueuePullFromChild(e){return new ye(this.upstreamExecutor,this.lastDone,[...this.activeChildExecutors,e],this.upstreamDone,this.combineChildResults,this.combineWithChildResult,this.onPull)}}class Dt{constructor(e,n){l(this,"value");l(this,"next");l(this,"_tag",Qs);this.value=e,this.next=n}close(e){const n=this.next.close(e);return n}enqueuePullFromChild(e){return this}}const nc="Pulled",sc="NoUpstream",rc="effect/ChannelUpstreamPullRequest",ic=Symbol.for(rc),oc={_A:t=>t},Hs={[ic]:oc},Tn=t=>{const e=Object.create(Hs);return e._tag=nc,e.value=t,e},cc=t=>{const e=Object.create(Hs);return e._tag=sc,e.activeDownstreamCount=t,e};class fe{constructor(e,n,s){l(this,"_activeSubexecutor");l(this,"_cancelled");l(this,"_closeLastSubstream");l(this,"_currentChannel");l(this,"_done");l(this,"_doneStack",[]);l(this,"_emitted");l(this,"_executeCloseLastSubstream");l(this,"_input");l(this,"_inProgressFinalizer");l(this,"_providedEnv");this._currentChannel=e,this._executeCloseLastSubstream=s,this._providedEnv=n}run(){let e;for(;e===void 0;)if(this._cancelled!==void 0)e=this.processCancellation();else if(this._activeSubexecutor!==void 0)e=this.runSubexecutor();else try{if(this._currentChannel===void 0)e=Ee();else if(Qe(this._currentChannel))this._currentChannel=R(this._currentChannel);else switch(this._currentChannel._tag){case Fs:{e=this.runBracketOut(this._currentChannel);break}case Ds:{const n=this._currentChannel.input;if(this._currentChannel=this._currentChannel.channel,this._input!==void 0){const s=this._input;this._input=void 0;const r=()=>p(n.awaitRead(),()=>y(()=>{const i=s.run();switch(i._tag){case Ve:return Y(s.getDone(),{onFailure:c=>n.error(c),onSuccess:c=>n.done(c)});case Ge:return p(n.emit(s.getEmit()),()=>r());case $e:return J(i.effect,{onFailure:c=>n.error(c),onSuccess:()=>r()});case Je:return ln(i,()=>r(),c=>n.error(c))}}));e=Ae(p(nt(r()),i=>I(()=>this.addFinalizer(c=>p(Pe(i),()=>y(()=>{const a=this.restorePipe(c,s);return a!==void 0?a:b}))))))}break}case an:{const n=new fe(this._currentChannel.value(),this._providedEnv,r=>I(()=>{const i=this._closeLastSubstream===void 0?b:this._closeLastSubstream;this._closeLastSubstream=o(i,P(r))}));n._input=this._input;const s=this._currentChannel;this._activeSubexecutor=new de(n,r=>s.k(r),void 0,[],(r,i)=>s.combineInners(r,i),(r,i)=>s.combineAll(r,i),r=>s.onPull(r),r=>s.onEmit(r)),this._closeLastSubstream=void 0,this._currentChannel=void 0;break}case Rs:{this._emitted=this._currentChannel.out,this._currentChannel=this._activeSubexecutor!==void 0?void 0:N,e=kt();break}case $s:{this.runEnsuring(this._currentChannel);break}case Ts:{e=this.doneHalt(this._currentChannel.error());break}case un:{this._doneStack.push(this._currentChannel.k),this._currentChannel=this._currentChannel.channel;break}case As:{const n=this._providedEnv===void 0?this._currentChannel.effect():o(this._currentChannel.effect(),yn(this._providedEnv));e=Ae(J(n,{onFailure:s=>{const r=this.doneHalt(s);return r!==void 0&&ht(r)?r.effect:b},onSuccess:s=>{const r=this.doneSucceed(s);return r!==void 0&&ht(r)?r.effect:b}}));break}case Ls:{const n=this._input,s=new fe(this._currentChannel.left(),this._providedEnv,r=>this._executeCloseLastSubstream(r));s._input=n,this._input=s,this.addFinalizer(r=>{const i=this.restorePipe(r,n);return i!==void 0?i:b}),this._currentChannel=this._currentChannel.right();break}case jo:{const n=this._providedEnv;this._providedEnv=this._currentChannel.context(),this._currentChannel=this._currentChannel.inner,this.addFinalizer(()=>I(()=>{this._providedEnv=n}));break}case xs:{const n=this._currentChannel;e=Ft(this._input,Q,s=>{try{this._currentChannel=n.more(s)}catch(r){this._currentChannel=n.done.onExit(Wi(r))}},s=>{const r=i=>n.done.onExit(i);this._currentChannel=r(s)});break}case zs:{e=this.doneSucceed(this._currentChannel.evaluate());break}case Ns:{e=this.doneSucceed(this._currentChannel.terminal);break}case Us:{this._currentChannel=this._currentChannel.channel();break}default:this._currentChannel._tag}}catch(n){this._currentChannel=F(es(n))}return e}getDone(){return this._done}getEmit(){return this._emitted}cancelWith(e){this._cancelled=e}clearInProgressFinalizer(){this._inProgressFinalizer=void 0}storeInProgressFinalizer(e){this._inProgressFinalizer=e}popAllFinalizers(e){const n=[];let s=this._doneStack.pop();for(;s;)s._tag==="ContinuationFinalizer"&&n.push(s.finalizer),s=this._doneStack.pop();const r=n.length===0?b:$t(n,e);return this.storeInProgressFinalizer(r),r}popNextFinalizers(){const e=[];for(;this._doneStack.length!==0;){const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt)return e;e.push(n),this._doneStack.pop()}return e}restorePipe(e,n){const s=this._input;return this._input=n,s!==void 0?s.close(e):b}close(e){let n;const s=this._inProgressFinalizer;s!==void 0&&(n=o(s,Xe(I(()=>this.clearInProgressFinalizer()))));let r;const i=this.popAllFinalizers(e);i!==void 0&&(r=o(i,Xe(I(()=>this.clearInProgressFinalizer()))));const c=this._activeSubexecutor===void 0?void 0:this._activeSubexecutor.close(e);if(!(c===void 0&&n===void 0&&r===void 0))return o(z(Rt(c)),Nt(z(Rt(n))),Nt(z(Rt(r))),O(([[a,u],d])=>o(a,We(u),We(d))),et,p(a=>y(()=>a)))}doneSucceed(e){if(this._doneStack.length===0)return this._done=W(e),this._currentChannel=void 0,Ee();const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt){this._doneStack.pop(),this._currentChannel=n.onSuccess(e);return}const s=this.popNextFinalizers();if(this._doneStack.length===0)return this._doneStack=s.reverse(),this._done=W(e),this._currentChannel=void 0,Ee();const r=$t(s.map(c=>c.finalizer),W(e));this.storeInProgressFinalizer(r);const i=o(r,Xe(I(()=>this.clearInProgressFinalizer())),et,p(()=>I(()=>this.doneSucceed(e))));return Ae(i)}doneHalt(e){if(this._doneStack.length===0)return this._done=B(e),this._currentChannel=void 0,Ee();const n=this._doneStack[this._doneStack.length-1];if(n._tag===rt){this._doneStack.pop(),this._currentChannel=n.onHalt(e);return}const s=this.popNextFinalizers();if(this._doneStack.length===0)return this._doneStack=s.reverse(),this._done=B(e),this._currentChannel=void 0,Ee();const r=$t(s.map(c=>c.finalizer),B(e));this.storeInProgressFinalizer(r);const i=o(r,Xe(I(()=>this.clearInProgressFinalizer())),et,p(()=>I(()=>this.doneHalt(e))));return Ae(i)}processCancellation(){return this._currentChannel=void 0,this._done=this._cancelled,this._cancelled=void 0,Ee()}runBracketOut(e){const n=et(J(this.provide(e.acquire()),{onFailure:s=>I(()=>{this._currentChannel=F(s)}),onSuccess:s=>I(()=>{this.addFinalizer(r=>this.provide(e.finalizer(s,r))),this._currentChannel=_(s)})}));return Ae(n)}provide(e){return this._providedEnv===void 0?e:o(e,yn(this._providedEnv))}runEnsuring(e){this.addFinalizer(e.finalizer),this._currentChannel=e.channel}addFinalizer(e){this._doneStack.push(new No(e))}runSubexecutor(){const e=this._activeSubexecutor;switch(e._tag){case js:return this.pullFromChild(e.childExecutor,e.parentSubexecutor,e.onEmit,e);case Qt:return this.pullFromUpstream(e);case Ht:return this.drainChildExecutors(e);case Qs:return this._emitted=e.value,this._activeSubexecutor=e.next,kt()}}replaceSubexecutor(e){this._currentChannel=void 0,this._activeSubexecutor=e}finishWithExit(e){const n=Y(e,{onFailure:s=>this.doneHalt(s),onSuccess:s=>this.doneSucceed(s)});return this._activeSubexecutor=void 0,n===void 0?b:tc(n)}finishSubexecutorWithCloseEffect(e,...n){this.addFinalizer(()=>o(n,ke(r=>o(I(()=>r(e)),p(i=>i!==void 0?i:b)),{discard:!0})));const s=o(e,Y({onFailure:r=>this.doneHalt(r),onSuccess:r=>this.doneSucceed(r)}));return this._activeSubexecutor=void 0,s}applyUpstreamPullStrategy(e,n,s){switch(s._tag){case vs:{const r=!e||n.some(i=>i!==void 0);return[s.emitSeparator,r?[void 0,...n]:n]}case Uo:{const r=!e||n.some(i=>i!==void 0);return[s.emitSeparator,r?[...n,void 0]:n]}}}pullFromChild(e,n,s,r){return Ft(e,Q,i=>{const c=s(i);switch(c._tag){case ws:break;case To:{this.finishWithDoneValue(e,n,c.value);break}case Ao:{const a=n.enqueuePullFromChild(r);this.replaceSubexecutor(a);break}}this._activeSubexecutor=new Dt(i,this._activeSubexecutor)},Y({onFailure:i=>{const c=this.handleSubexecutorFailure(e,n,i);return c===void 0?void 0:$n(c)},onSuccess:i=>{this.finishWithDoneValue(e,n,i)}}))}finishWithDoneValue(e,n,s){const r=n;switch(r._tag){case Qt:{const i=new de(r.upstreamExecutor,r.createChild,r.lastDone!==void 0?r.combineChildResults(r.lastDone,s):s,r.activeChildExecutors,r.combineChildResults,r.combineWithChildResult,r.onPull,r.onEmit);this._closeLastSubstream=e.close(W(s)),this.replaceSubexecutor(i);break}case Ht:{const i=new ye(r.upstreamExecutor,r.lastDone!==void 0?r.combineChildResults(r.lastDone,s):s,r.activeChildExecutors,r.upstreamDone,r.combineChildResults,r.combineWithChildResult,r.onPull);this._closeLastSubstream=e.close(W(s)),this.replaceSubexecutor(i);break}}}handleSubexecutorFailure(e,n,s){return this.finishSubexecutorWithCloseEffect(B(s),r=>n.close(r),r=>e.close(r))}pullFromUpstream(e){if(e.activeChildExecutors.length===0)return this.performPullFromUpstream(e);const n=e.activeChildExecutors[0],s=new de(e.upstreamExecutor,e.createChild,e.lastDone,e.activeChildExecutors.slice(1),e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit);if(n===void 0)return this.performPullFromUpstream(s);this.replaceSubexecutor(new tt(n.childExecutor,s,n.onEmit))}performPullFromUpstream(e){return Ft(e.upstreamExecutor,n=>{const s=this._closeLastSubstream===void 0?b:this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(s),P(n))},n=>{if(this._closeLastSubstream!==void 0){const c=this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(c),O(()=>{const a=new fe(e.createChild(n),this._providedEnv,this._executeCloseLastSubstream);a._input=this._input;const[u,d]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Tn(n)));this._activeSubexecutor=new tt(a,new de(e.upstreamExecutor,e.createChild,e.lastDone,d,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),st(u)&&(this._activeSubexecutor=new Dt(u.value,this._activeSubexecutor))}))}const s=new fe(e.createChild(n),this._providedEnv,this._executeCloseLastSubstream);s._input=this._input;const[r,i]=this.applyUpstreamPullStrategy(!1,e.activeChildExecutors,e.onPull(Tn(n)));this._activeSubexecutor=new tt(s,new de(e.upstreamExecutor,e.createChild,e.lastDone,i,e.combineChildResults,e.combineWithChildResult,e.onPull,e.onEmit),e.onEmit),st(r)&&(this._activeSubexecutor=new Dt(r.value,this._activeSubexecutor))},n=>{if(e.activeChildExecutors.some(i=>i!==void 0)){const i=new ye(e.upstreamExecutor,e.lastDone,[void 0,...e.activeChildExecutors],e.upstreamExecutor.getDone(),e.combineChildResults,e.combineWithChildResult,e.onPull);if(this._closeLastSubstream!==void 0){const c=this._closeLastSubstream;return this._closeLastSubstream=void 0,o(this._executeCloseLastSubstream(c),O(()=>this.replaceSubexecutor(i)))}this.replaceSubexecutor(i);return}const s=this._closeLastSubstream,r=this.finishSubexecutorWithCloseEffect(o(n,qi(i=>e.combineWithChildResult(e.lastDone,i))),()=>s,i=>e.upstreamExecutor.close(i));return r===void 0?void 0:$n(r)})}drainChildExecutors(e){if(e.activeChildExecutors.length===0){const i=this._closeLastSubstream;return i!==void 0&&this.addFinalizer(()=>x(i)),this.finishSubexecutorWithCloseEffect(e.upstreamDone,()=>i,c=>e.upstreamExecutor.close(c))}const n=e.activeChildExecutors[0],s=e.activeChildExecutors.slice(1);if(n===void 0){const[i,c]=this.applyUpstreamPullStrategy(!0,s,e.onPull(cc(s.reduce((a,u)=>u!==void 0?a+1:a,0))));return this.replaceSubexecutor(new ye(e.upstreamExecutor,e.lastDone,c,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull)),st(i)?(this._emitted=i.value,kt()):void 0}const r=new ye(e.upstreamExecutor,e.lastDone,s,e.upstreamDone,e.combineChildResults,e.combineWithChildResult,e.onPull);this.replaceSubexecutor(new tt(n.childExecutor,r,n.onEmit))}}const Rt=t=>t!==void 0?t:b,$t=(t,e)=>o(ke(t,n=>z(n(e))),O(n=>o(Mi(n),ni(()=>Bi))),p(n=>y(()=>n))),ln=(t,e,n)=>{const s=[t],r=()=>{const i=s.pop();if(i===void 0||i.upstream===void 0)return ci("Unexpected end of input for channel execution");const c=i.upstream.run();switch(c._tag){case Ge:{const a=i.onEmit(i.upstream.getEmit());return s.length===0?a===void 0?y(e):o(a,J({onFailure:n,onSuccess:e})):a===void 0?y(()=>r()):o(a,J({onFailure:n,onSuccess:()=>r()}))}case Ve:{const a=i.onDone(i.upstream.getDone());return s.length===0?a===void 0?y(e):o(a,J({onFailure:n,onSuccess:e})):a===void 0?y(()=>r()):o(a,J({onFailure:n,onSuccess:()=>r()}))}case $e:return s.push(i),o(i.onEffect(c.effect),Xt(a=>y(()=>{const u=i.onDone(B(a));return u===void 0?b:u})),J({onFailure:n,onSuccess:()=>r()}));case Je:return s.push(i),s.push(c),y(()=>r())}};return r()},ac=t=>o(Ks(t),Ut),Ks=t=>{const e=(n,s,r)=>ai(I(()=>new fe(t,void 0,Q)),i=>y(()=>o(it(i.run(),i),ts(n),P(w(n)),wn(w(s)))),(i,c)=>{const a=i.close(c);return a===void 0?b:en(a,u=>Xi(r,Z(u)))});return Zt(n=>p(si,s=>o(ii([to(s,oi),q(),q()]),p(([r,i,c])=>o(pe(n(e(i,c,r))),p(a=>o(ri(()=>ee(c,void 0)),P(n(w(i))),wn(ro(a)))))))))},it=(t,e)=>{const n=t;switch(n._tag){case $e:return o(n.effect,p(()=>it(e.run(),e)));case Ge:return it(e.run(),e);case Ve:return y(()=>e.getDone());case Je:return ln(n,()=>it(e.run(),e),Z)}},Vs="Done",uc="Await",lc="effect/ChannelMergeDecision",hc=Symbol.for(lc),Gs={[hc]:{_R:t=>t,_E0:t=>t,_Z0:t=>t,_E:t=>t,_Z:t=>t}},dc=t=>{const e=Object.create(Gs);return e._tag=Vs,e.effect=t,e},Kt=t=>{const e=Object.create(Gs);return e._tag=uc,e.f=t,e},Js="BothRunning",Ys="LeftDone",Zs="RightDone",fc="effect/ChannelMergeState",An=Symbol.for(fc),hn={[An]:An},Tt=(t,e)=>{const n=Object.create(hn);return n._tag=Js,n.left=t,n.right=e,n},Ln=t=>{const e=Object.create(hn);return e._tag=Ys,e.f=t,e},xn=t=>{const e=Object.create(hn);return e._tag=Zs,e.f=t,e},Xs="BackPressure",er="BufferSliding",pc="effect/ChannelMergeStrategy",zn=Symbol.for(pc),tr={[zn]:zn},mc=t=>{const e=Object.create(tr);return e._tag=Xs,e},_c=t=>{const e=Object.create(tr);return e._tag=er,e},gc=h(2,(t,{onBackPressure:e,onBufferSliding:n})=>{switch(t._tag){case Xs:return e();case er:return n()}}),be="Empty",Le="Emit",xe="Error",ze="Done",nr=t=>({_tag:be,notifyProducer:t}),At=t=>({_tag:Le,notifyConsumers:t}),Sc=t=>({_tag:xe,cause:t}),Ec=t=>({_tag:ze,done:t});class bc{constructor(e){l(this,"ref");this.ref=e}awaitRead(){return he(Te(this.ref,e=>e._tag===be?[w(e.notifyProducer),e]:[b,e]))}get close(){return ui(e=>this.error(li(e)))}done(e){return he(Te(this.ref,n=>{switch(n._tag){case be:return[w(n.notifyProducer),n];case Le:return[ke(n.notifyConsumers,s=>ee(s,Fe(e)),{discard:!0}),Ec(e)];case xe:return[Se,n];case ze:return[Se,n]}}))}emit(e){return p(q(),n=>he(Te(this.ref,s=>{switch(s._tag){case be:return[w(s.notifyProducer),s];case Le:{const r=s.notifyConsumers[0],i=s.notifyConsumers.slice(1);if(r!==void 0)return[ee(r,Ue(e)),i.length===0?nr(n):At(i)];throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues")}case xe:return[Se,s];case ze:return[Se,s]}})))}error(e){return he(Te(this.ref,n=>{switch(n._tag){case be:return[w(n.notifyProducer),n];case Le:return[ke(n.notifyConsumers,s=>ss(s,e),{discard:!0}),Sc(e)];case xe:return[Se,n];case ze:return[Se,n]}}))}get take(){return this.takeWith(e=>B(rs(e,Fe)),e=>W(e),e=>fs(Ue(e)))}takeWith(e,n,s){return p(q(),r=>he(Te(this.ref,i=>{switch(i._tag){case be:return[P(ee(i.notifyProducer,void 0),at(w(r),{onFailure:e,onSuccess:U({onLeft:s,onRight:n})})),At([r])];case Le:return[at(w(r),{onFailure:e,onSuccess:U({onLeft:s,onRight:n})}),At([...i.notifyConsumers,r])];case xe:return[x(e(i.cause)),i];case ze:return[x(s(i.done)),i]}})))}}const sr=()=>o(q(),p(t=>ns(nr(t))),O(t=>new bc(t))),dt=h(2,(t,e)=>Jo(t,e,()=>{},()=>{})),rr=t=>{const e=le({onInput:()=>e,onFailure:F,onDone:He});return T(t,e)},ir=h(2,(t,e)=>Yo(t,()=>e)),Cc=t=>m(t,Q),dn=t=>V(t.takeWith(F,e=>m(_(e),()=>dn(t)),He)),or=h(2,(t,e)=>m(t,n=>Bs(()=>e(n)))),St=h(2,(t,e)=>{const n=Re({onInput:s=>m(_(e(s)),()=>n),onFailure:te,onDone:ce});return T(t,n)}),yc=h(3,(t,e,n)=>o(Ne(function*(s){const r=yield*s(Me(on(n),u=>Be(u))),i=yield*s(q()),c=n===Number.POSITIVE_INFINITY?u=>Q:(yield*s(cs(n))).withPermits,a=yield*s(Ie(t));return yield*s(J(a,{onFailure:u=>$(r,Z(u)),onSuccess:u=>U(u,{onLeft:d=>{const E=c(n);return P(ut(E(b)),Mt($(r,x(Fe(d)))))},onRight:d=>Ne(function*(E){const v=yield*E(q()),D=yield*E(q());yield*E(Mt($(r,O(w(v),Ue)))),yield*E(ee(D,void 0),P(o(Zt(k=>o(z(k(w(i))),fi(z(k(e(d)))),p(ne=>y(()=>ne)))),en(k=>ss(i,k)),ts(v))),c(1),pe),yield*E(w(D))})})}),pi,ut,pe),r}),O(s=>{const r=V(at(he(jt(s)),{onFailure:F,onSuccess:U({onLeft:ce,onRight:i=>m(_(i),()=>r)})}));return r}),pn)),wc=t=>e=>Pc(t)(e,mi),Pc=({bufferSize:t=16,concurrency:e,mergeStrategy:n=mc()})=>(s,r)=>o(Ne(function*(i){const c=e==="unbounded"?Number.MAX_SAFE_INTEGER:e,a=yield*i(sr()),u=dn(a),d=yield*i(Me(on(t),C=>Be(C))),E=yield*i(Me(ys(),C=>Be(C))),v=yield*i(ns(M())),D=yield*i(q()),k=(yield*i(cs(c))).withPermits,ne=yield*i(Ie(s)),G=C=>o(p(C,U({onLeft:f=>x(j(f)),onRight:f=>we($(d,x(Ue(f))),M())})),Ei(st),p(f=>bi(v,_e({onNone:()=>j(f.value),onSome:H=>j(r(H,f.value))}))),Xt(f=>as(f)?Z(f):o($(d,Z(f)),P(ee(D,void 0)),Mt)));return yield*i(J(ne,{onFailure:C=>o($(d,Z(C)),P(x(!1))),onSuccess:U({onLeft:C=>is(w(D),k(c)(b),{onSelfDone:(f,H)=>we(Pe(H),!1),onOtherDone:(f,H)=>P(Pe(H),o(_i(v),p(_e({onNone:()=>$(d,x(Fe(C))),onSome:ge=>$(d,x(Fe(r(ge,C))))})),we(!1)))}),onRight:C=>gc(n,{onBackPressure:()=>Ne(function*(f){const H=yield*f(q()),ge=o(u,T(C),Ie,p(yt=>Ot(G(yt),w(D))),Ut);return yield*f(ee(H,void 0),P(ge),k(1),pe),yield*f(w(H)),!(yield*f(Pn(D)))}),onBufferSliding:()=>Ne(function*(f){const H=yield*f(q()),ge=yield*f(q()),En=yield*f(Do(E));yield*f(jt(E),p(wt=>ee(wt,void 0)),gi(()=>En>=c)),yield*f($(E,H));const yt=o(u,T(C),Ie,p(wt=>o(G(wt),Ot(w(D)),Ot(w(H)))),Ut);return yield*f(ee(ge,void 0),P(yt),k(1),pe),yield*f(w(ge)),!(yield*f(Pn(D)))})})})}),Si(Q),pe),[d,a]}),O(([i,c])=>{const a=o(jt(i),he,at({onFailure:F,onSuccess:U({onLeft:ce,onRight:u=>m(_(u),()=>a)})}),V);return qs(a,c)}),pn),cr=h(3,(t,e,n)=>wc(n)(St(t,e))),ar=h(2,(t,e)=>pn(p(sr(),n=>{const s=dn(n);return O(Nt(Ie(T(s,t)),Ie(T(s,e.other))),([r,i])=>{const c=(u,d,E)=>(v,D,k)=>{const ne=G=>{const C=G;return C._tag===Vs?x(R(P(Pe(d),C.effect))):O(so(d),Y({onFailure:f=>R(C.f(B(f))),onSuccess:U({onLeft:f=>R(C.f(W(f))),onRight:f=>Et(_(f),a(k(C.f)))})}))};return Y(u,{onFailure:G=>ne(v(B(G))),onSuccess:U({onLeft:G=>ne(v(W(G))),onRight:G=>x(m(_(G),()=>m(R(nt(E)),C=>a(D(C,d)))))})})},a=u=>{switch(u._tag){case Js:{const d=ut(Dn(u.left)),E=ut(Dn(u.right));return V(is(d,E,{onSelfDone:(v,D)=>P(Pe(D),c(v,u.right,r)(e.onSelfDone,Tt,k=>Ln(k))),onOtherDone:(v,D)=>P(Pe(D),c(v,u.left,i)(e.onOtherDone,(k,ne)=>Tt(ne,k),k=>xn(k)))}))}case Ys:return V(O(z(i),Y({onFailure:d=>R(u.f(B(d))),onSuccess:U({onLeft:d=>R(u.f(W(d))),onRight:d=>m(_(d),()=>a(Ln(u.f)))})})));case Zs:return V(O(z(r),Y({onFailure:d=>R(u.f(B(d))),onSuccess:U({onLeft:d=>R(u.f(W(d))),onRight:d=>m(_(d),()=>a(xn(u.f)))})})))}};return o(R(_t(nt(r),nt(i),(u,d)=>Tt(u,d))),m(a),qs(n))})}))),fn=h(2,(t,e)=>Ke(()=>{let n;const s=Re({onInput:i=>m(_(i),()=>s),onFailure:i=>(n=kc(i),F(es(n))),onDone:ce}),r=le({onInput:i=>o(_(i),m(()=>r)),onFailure:i=>hi(i)&&Fc(i.defect)&&di(i.defect,n)?te(i.defect.error):F(i),onDone:ce});return T(T(T(t,s),e),r)})),ur=t=>m(t,()=>ur(t)),Oc=t=>ac(rr(t)),lr=t=>V(Zt(e=>O(no(),n=>Ko(en(e(eo(n)(t)),s=>Fn(n,B(s))),(s,r)=>Fn(n,r))))),Ie=t=>O(Me(I(()=>new fe(t,void 0,Q)),(e,n)=>{const s=e.close(n);return s===void 0?b:s}),e=>y(()=>Vt(e.run(),e))),Vt=(t,e)=>{const n=t;switch(n._tag){case Ve:return Y(e.getDone(),{onFailure:Z,onSuccess:s=>x(Fe(s))});case Ge:return x(Ue(e.getEmit()));case $e:return o(n.effect,p(()=>Vt(e.run(),e)));case Je:return ln(n,()=>Vt(e.run(),e),s=>Z(s))}},V=t=>Cc(R(t)),pn=t=>Go(lr(t),(e,n)=>e,(e,n)=>e),Ic=(...t)=>Ye(zt(t)),Ye=t=>hr(0,t.length,t),hr=(t,e,n)=>t===e?N:o(_(o(n,os(t))),m(()=>hr(t+1,e,n))),vc=h(t=>Ws(t[1]),(t,e,n)=>n?.concurrent?ar(t,{other:e,onSelfDone:s=>Kt(r=>y(()=>In(s,r))),onOtherDone:s=>Kt(r=>y(()=>In(r,s)))}):m(t,s=>or(e,r=>[s,r]))),Et=h(t=>Ws(t[1]),(t,e,n)=>n?.concurrent?or(vc(t,e,{concurrent:!0}),s=>s[1]):m(t,()=>e)),Gt=Symbol.for("effect/Channel/ChannelException"),kc=t=>({_tag:"ChannelException",[Gt]:Gt,error:t}),Fc=t=>mt(t,Gt),Dc=Symbol.for("effect/Sink"),Rc={_R:t=>t,_E:t=>t,_In:t=>t,_L:t=>t,_Z:t=>t};var Ya;class mn{constructor(e){l(this,"channel");l(this,Ya,Rc);this.channel=e}pipe(){return ae(this,arguments)}}Ya=Dc;const $c=t=>new mn(Ke(()=>_n(t()))),Tc=(t,e,n)=>$c(()=>new mn(dr(t,e,n))),dr=(t,e,n)=>e(t)?Re({onInput:s=>dr(n(t,s),e,n),onFailure:te,onDone:()=>ce(t)}):ce(t),Ac=(t,e)=>Tc(t,Ci,e),Lc=t=>new mn(R(t)),xc=()=>Ac(M(),(t,e)=>yi(wi(e),()=>t)),_n=t=>Qe(t)?_n(Lc(t)):t.channel,zc=dc,Nc=Kt,Uc="Left",Mc="Right",Wc="Both",qc="Either",Bc={_tag:Uc},jc={_tag:Mc},fr={_tag:Wc},Qc={_tag:qc},Hc=t=>{switch(t){case"left":return Bc;case"right":return jc;case"both":return fr;case"either":return Qc;default:return t}},Kc=fr,Vc="effect/Take",Gc=Symbol.for(Vc),Jc={_E:t=>t,_A:t=>t};var Za;class bt{constructor(e){l(this,"exit");l(this,Za,Jc);this.exit=e}pipe(){return ae(this,arguments)}}Za=Gc;const Nn=t=>new bt(W(t)),Un=new bt(fs(M())),Yc=t=>new bt(B(o(t,rs(j)))),Zc=t=>new bt(W(ue(t))),Xc=()=>us(M()),ea=t=>ls(Z(t),j),ta="effect/Stream",pr=Symbol.for(ta),na={_R:t=>t,_E:t=>t,_A:t=>t};var Xa;class S{constructor(e){l(this,"channel");l(this,Xa,na);this.channel=e}pipe(){return ae(this,arguments)}}Xa=pr;const gn=t=>mt(t,pr)||Qe(t),mr=4096,sa=h(2,(t,e)=>ra(t,n=>U(Xn(n),{onLeft:e,onRight:ua}))),ra=h(2,(t,e)=>new S(o(g(t),Vo(n=>g(e(n)))))),ia=t=>o(t,Sa(ue)),oa=t=>Ze(Ii(t)),ca=new S(_(je())),aa=h(2,(t,e)=>new S(o(g(t),ir(e)))),ua=t=>Ze(Z(t)),Sn=h(t=>gn(t[0]),(t,e,n)=>{const s=n?.bufferSize??16;return n?.switch?Jt(n?.concurrency,()=>Mn(t,1,s,e),r=>Mn(t,r,s,e)):Jt(n?.concurrency,()=>new S(dt(g(t),r=>o(r,ds(i=>g(e(i))),Fi(N,(i,c)=>o(i,Et(c)))))),r=>new S(o(g(t),dt(Ye),cr(i=>g(e(i)),n))))}),Jt=(t,e,n)=>{switch(t){case void 0:return e();case"unbounded":return n(Number.MAX_SAFE_INTEGER);default:return t>1?n(t):e()}},Mn=h(4,(t,e,n,s)=>new S(o(g(t),dt(Ye),cr(r=>g(s(r)),{concurrency:e,mergeStrategy:_c(),bufferSize:n})))),la=h(t=>gn(t[0]),(t,e)=>Sn(t,Q,e)),ha=t=>{const e=le({onInput:n=>m(Ye(n),()=>e),onFailure:F,onDone:()=>N});return new S(o(g(t),T(e)))},da=t=>{const e=(s,r)=>{const[i,c]=o(s,Di(u=>!Wt(u))),a=o($i(c),_e({onNone:()=>r,onSome:Y({onFailure:u=>_e(Ri(u),{onNone:()=>N,onSome:F}),onSuccess:()=>N})}));return o(_(o(i,Ti(u=>Wt(u)?j(u.value):M()))),m(()=>a))},n=le({onInput:s=>e(s,n),onFailure:s=>F(s),onDone:()=>N});return new S(o(g(t),T(n)))},_r=t=>ha(da(o(t,ft(e=>e.exit)))),g=t=>{if("channel"in t)return t.channel;if(Qe(t))return g(Ze(t));throw new TypeError("Expected a Stream.")},fa=t=>new S(Gn(t)?N:_(t)),Ze=t=>o(t,ls(j),pa),pa=t=>new S(V(hs(t,{onFailure:_e({onNone:()=>N,onSome:te}),onSuccess:e=>_(ue(e))}))),gr=(t,e)=>o($o(t,1,e?.maxChunkSize??mr),Xt(n=>o(Ro(t),p(s=>s&&as(n)?Xc():ea(n)))),Oa,e?.shutdown?aa(Be(t)):Q),ma=h(2,(t,e)=>o(t,wa(e),ia)),ft=h(2,(t,e)=>new S(o(g(t),St(ds(e))))),_a=h(3,(t,e,n)=>{const s=r=>Re({onInput:i=>{const[c,a]=Pi(i,r,n);return m(_(a),()=>s(c))},onFailure:te,onDone:()=>N});return new S(o(g(t),T(s(e))))}),ga=h(3,(t,e,n)=>Ct(()=>{const s=r=>Re({onInput:i=>o(y(()=>{const c=[],a=u=>I(()=>{c.push(u)});return o(i,vi(r,(u,d)=>o(n(u,d),p(([E,v])=>o(a(v),we(E))))),hs({onFailure:u=>c.length!==0?Et(_(De(c)),te(u)):te(u),onSuccess:u=>m(_(De(c)),()=>s(u))}))}),V),onFailure:te,onDone:()=>N});return new S(o(g(t),fn(s(e))))})),Sa=h(2,(t,e)=>new S(o(g(t),St(e)))),Yt=h(2,(t,e)=>{const n=s=>{const r=s.next();if(r.done)return le({onInput:i=>n(i[Symbol.iterator]()),onFailure:F,onDone:He});{const i=r.value;return V(O(e(i),c=>m(_(ue(c)),()=>n(s))))}};return new S(o(g(t),T(Ke(()=>n(je()[Symbol.iterator]())))))}),Ea=h(3,(t,e,n)=>new S(o(g(t),dt(Ye),yc(n,e),St(ue)))),ba=h(t=>gn(t[1]),(t,e,n)=>Ca(t,e,{onSelf:Q,onOther:Q,haltStrategy:n?.haltStrategy})),Ca=h(3,(t,e,n)=>{const s=n.haltStrategy?Hc(n.haltStrategy):Kc,r=i=>c=>i||!Wt(c)?zc(y(()=>c)):Nc(a=>y(()=>a));return new S(ar(g(ft(t,n.onSelf)),{other:g(ft(e,n.onOther)),onSelfDone:r(s._tag==="Either"||s._tag==="Left"),onOtherDone:r(s._tag==="Either"||s._tag==="Right")}))}),ya=(t,e,n=mr)=>Ct(()=>{if(t>e)return ca;const s=(r,i,c)=>{const a=i-r+1;return a>c?o(_(On(r,r+c-1)),m(()=>s(r+c,i,c))):_(On(r,r+a-1))};return new S(s(t,e,n))}),wa=h(2,(t,e)=>Ct(()=>{const n=Math.max(e,1),s=ot(new Pa(n),n);return new S(o(g(t),T(s)))})),ot=(t,e)=>le({onInput:n=>{if(n.length===e&&t.isEmpty())return m(_(n),()=>ot(t,e));if(n.length>0){const s=[];let r,i=0;for(;i<n.length;){for(;i<n.length&&r===void 0;)r=t.write(o(n,os(i))),i=i+1;r!==void 0&&(s.push(r),r=void 0)}return m(Ic(...s),()=>ot(t,e))}return Ke(()=>ot(t,e))},onFailure:n=>Et(t.emitIfNotEmpty(),F(n)),onDone:()=>t.emitIfNotEmpty()});class Pa{constructor(e){l(this,"n");l(this,"builder",[]);l(this,"pos",0);this.n=e}isEmpty(){return this.pos===0}write(e){if(this.builder.push(e),this.pos+=1,this.pos===this.n){const n=De(this.builder);return this.builder=[],this.pos=0,n}}emitIfNotEmpty(){return this.pos!==0?_(De(this.builder)):N}}const Oa=t=>Ta(t,e=>o(O(e,n=>j([n,e])),Ai(_e({onNone:()=>x(M()),onSome:us})))),Ia=t=>new S(ur(_(ue(t)))),va=h(2,(t,e)=>o(g(t),fn(_n(e)),Oc)),ka=t=>o(t,va(xc())),Fa=t=>new S(ir(lr(o(t,O(ue))),b)),Da=t=>fa(ue(t)),Ct=t=>new S(Ke(()=>g(t()))),Ra=h(2,(t,e)=>{if(!Number.isInteger(e))return oa(Oi(`${e} must be an integer`));const n=s=>Re({onInput:r=>{const i=o(r,ki(Math.min(s,Number.POSITIVE_INFINITY))),c=Math.max(0,s-i.length);return c>0?o(_(i),m(()=>n(c))):_(i)},onFailure:te,onDone:He});return new S(o(g(t),fn(0<e?n(e):N)))}),$a=h(2,(t,e)=>Yt(t,n=>we(e(n),n))),Ta=(t,e)=>Ct(()=>{const n=s=>V(O(e(s),_e({onNone:()=>N,onSome:([r,i])=>m(_(r),()=>n(i))})));return new S(n(t))}),Aa=t=>la(Fa(t)),La=t=>Li(xi,e=>t(zi(e,Ni))),xa=(...t)=>La(e=>e.log(...t)),su=xa,za="effect/GroupBy",Sr=Symbol.for(za),Na={_R:t=>t,_E:t=>t,_K:t=>t,_V:t=>t},Ua=t=>mt(t,Sr),Ma=h(t=>Ua(t[0]),(t,e,n)=>Sn(t.grouped,([s,r])=>e(s,_r(gr(r,{shutdown:!0}))),{concurrency:"unbounded",bufferSize:n?.bufferSize??16})),Wa=t=>({[Sr]:Na,pipe(){return ae(this,arguments)},grouped:t}),qa=h(t=>typeof t[0]!="function",(t,e,n)=>n?.key?Ma(Ba(t,n.key,{bufferSize:n.bufferSize}),(s,r)=>Yt(r,e)):Jt(n?.concurrency,()=>Yt(t,e),s=>n?.unordered?Sn(t,r=>Ze(e(r)),{concurrency:s}):Ea(t,s,e))),Ba=h(t=>typeof t[0]!="function",(t,e,n)=>{const s=(r,i)=>le({onInput:c=>m(R(ke(ja(c,e),([a,u])=>{const d=r.get(a);return d===void 0?o(on(n?.bufferSize??16),p(E=>o(I(()=>{r.set(a,E)}),P($(i,Zc([a,E]))),P(o($(E,Nn(u)),It(v=>vt(v)?j(b):M())))))):It($(d,Nn(u)),E=>vt(E)?j(b):M())},{discard:!0})),()=>s(r,i)),onFailure:c=>R($(i,Yc(c))),onDone:()=>o(R(o(ke(r.entries(),([c,a])=>o($(a,Un),It(u=>vt(u)?j(b):M())),{discard:!0}),P($(i,Un)))))});return Wa(Aa(o(I(()=>new Map),p(r=>o(Me(ys(),i=>Be(i)),p(i=>o(t,g,T(s(r,i)),rr,Ks,pe,we(_r(gr(i,{shutdown:!0}))))))))))}),ja=h(2,(t,e)=>{const n=[],s=t[Symbol.iterator](),r=new Map;let i;for(;(i=s.next())&&!i.done;){const c=i.value,a=e(c);if(r.has(a))r.get(a).push(c);else{const u=[c];n.push([a,u]),r.set(a,u)}}return De(n.map(c=>[c[0],De(c[1])]))}),ru=sa,iu=Ze,ou=ma,cu=ft,au=_a,uu=ga,lu=qa,hu=ba,du=ya,fu=Ia,pu=ka,mu=Da,_u=Ra,gu=$a;export{uu as a,fu as b,ru as c,au as d,du as e,hu as f,ou as g,iu as h,_u as i,lu as j,su as l,cu as m,pu as r,mu as s,gu as t};
